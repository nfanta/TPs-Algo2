\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage[]{algorithm2e}

\SetKwInput{KwData}{Complejidad}
\SetAlgorithmName{Algoritmo}{Algoritmo}{Lista de algoritmos}
\SetAlCapSkip{1em}


\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

\section{Módulo Lista Enlazada($\alpha$)}


\begin{Interfaz}
  
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Secuencia$(\alpha)$}, \tadNombre{Iterador Bidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{lista$(\alpha)$}, \TipoVariable{itLista($\alpha$)}.

  \Titulo{Operaciones básicas de lista}

  \InterfazFuncion{Vacía}{}{lista$(\alpha)$}%
  {$res \igobs \secuencia{}$}%
  [$\Theta(1)$]
  [genera una lista vacía.]

  \InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}
  [$l \igobs l_0$]
  {$l \igobs \secuencia{a}[l_0]$ $\land$ $res$ $=$ CrearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($res$) $=$ $l$)}
  [$\Theta(copy(a))$]
  [agrega el elemento $a$ como primer elemento de la lista.  Retorna un iterador a $l$, de forma tal que Siguiente devuelva $a$.]
  [el elemento $a$ agrega por copia. El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

 
  \Titulo{Operaciones del iterador}

  \InterfazFuncion{CrearIt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Siguiente} se obtenga el primer elemento de $l$.]
  [el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

  \InterfazFuncion{CrearItUlt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi($l$, \secuencia{}) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Anterior} se obtenga el último elemento de $l$.]  
  [el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación de la lista}

  \begin{Estructura}{lista$(\alpha)$}[lst]
    \begin{Tupla}[lst]
      \tupItem{primero}{puntero(nodo)}%
      \tupItem{longitud}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{dato}{$\alpha$}%
      \tupItem{anterior}{puntero(nodo)}%
      \tupItem{siguiente}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~

  \tadOperacion{FinLst}{lst}{lst}{}
  \tadAxioma{FinLst($l$)}{Lst($l$.primero\DRef siguiente, $l$.longitud $-$ $\min$\{$l$.longitud, $1$\})}

  ~

  \tadOperacion{Lst}{puntero(nodo),nat}{lst}{}
  \tadAxioma{Lst($p,n$)}{$\langle p, n\rangle$}

  ~
 
  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

  \Titulo{Representación del iterador}

  \begin{Estructura}{itLista($\alpha$)}[iter]
    \begin{Tupla}[iter]
      \tupItem{siguiente}{puntero(nodo)}%
      \tupItem{lista}{puntero(lst)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{Rep($\ast$($it$.lista)) $\yluego$ ($it$.siguiente $=$ NULL $\oluego$ ($\exists i$: nat)(Nodo($\ast it$.lista, $i$) $=$ $it$.siguiente)}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{Siguientes($b$) $=$ Abs(Sig($it$.lista, $it$.siguiente)) $\land$\\
    Anteriores($b$) $=$ Abs(Ant($it$.lista, $it$.siguiente))}

  ~

  \tadOperacion{Sig}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Sig($i, p$)}{Lst($p$, $l$\DRef longitud $-$ Pos($\ast l$, $p$))}

  ~

  \tadOperacion{Ant}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Ant($i, p$)}{Lst(\IF $p$ $=$ $l$\DRef primero THEN NULL ELSE $l$\DRef primero FI, Pos($\ast l$, $p$))}

  ~

  {\small Nota: cuando $p$ $=$ NULL, Pos devuelve la longitud de la lista, lo cual está bien, porque significa que el iterador no tiene siguiente.}
  \tadOperacion{Pos}{lst/l,puntero(nodo)/p}{puntero(nodo)}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Pos($l$,$p$)}{\IF $l$.primero $=$ $p$ $\lor$ $l$.longitud $=$ $0$ THEN $0$ ELSE $1$ $+$ Pos(FinLst($l$), $p$) FI}


\end{Representacion}


\section{Módulo Agentes}


\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{Agentes}

  \textbf{géneros}: \TipoVariable{agentes}

  \Titulo{Operaciones básicas de agentes}

  \InterfazFuncion{NuevoAgentes}{\In{as}{dicc(placa, posicion)}}{agentes}%
  [true]
  {$res \igobs$ nuevo($as$)}%
  [O(N$a$) //Revisar al hacer algoritmo]
  [Crea un nuevo contenedor de Agentes con los agentes contenidos en $as$. N$a$ es la cantidad de agentes definidos en $as$]

  \InterfazFuncion{AgregarSancion}{\In{a}{placa}, \Inout{as}{agentes}}{}%
  [estaAgente($a, as$) $\land$ as = $as_{0}$]
  {$as \igobs$ agregarSancion($a, as_{0}$)}%
  [$\Theta(1)$]
  [Agrega una sancion al agente $a$]

  \InterfazFuncion{AgregarSancion}{\In{a}{placa}, \In{p}{posicion}, \Inout{as}{agentes}}{}%
  [estaAgente($a, as$) $\land$ as = $as_{0}$]
  {$as \igobs$ cambiarPos($a, p, as_{0}$)}%
  [$\Theta(1)$]
  [Modifica la posicion del agente $a$, para que sea $p$]

  \InterfazFuncion{AgregarCaptura}{\In{a}{placa}, \Inout{as}{agentes}}{}%
  [estaAgente($a, as$) $\land$ as = $as_{0}$]
  {$as \igobs$ agregarCaptura($a, as_{0}$)}%
  [$\Theta(1)$]
  [Agrega una captura al agente $a$]

  \InterfazFuncion{PosAgente}{\In{a}{placa}, \In{as}{agentes}}{posicion}%
  [estaAgente($a, as$)]
  {$res \igobs$ posicionAgente($a, as$)}%
  [$\Theta(1)$]
  [Devuelve la posicion actual del agente $a$]

  \InterfazFuncion{PosAgente}{\In{a}{placa}, \In{as}{agentes}}{posicion}%
  [estaAgente($a, as$)]
  {$res \igobs$ posicionAgente($a, as$)}%
  [$\Theta(1)$]
  [Devuelve la posicion actual del agente $a$]

  \InterfazFuncion{SancionesAgente}{\In{a}{placa}, \In{as}{agentes}}{nat}%
  [estaAgente($a, as$)]
  {$res \igobs$ sancionesAgente($a, as$)}%
  [$\Theta(1)$]
  [Devuelve las sanciones actuales del agente $a$]

  \InterfazFuncion{CapturasAgente}{\In{a}{placa}, \In{as}{agentes}}{nat}%
  [estaAgente($a, as$)]
  {$res \igobs$ capturasAgente($a, as$)}%
  [$\Theta(1)$]
  [Devuelve la cantidad de capturas actuales del agente $a$]

  \InterfazFuncion{MasVigilante}{\In{as}{agentes}}{placa}%
  [true]
  {$res \igobs$ masVigilante($as$)}%
  [$\Theta(1)$]
  [Devuelve el agente que mas capturas tiene en $as$. Si hubiera mas de uno, devuelve el de menor placa.]

  \InterfazFuncion{ConMismasSanciones}{\In{a}{placa}, \In{as}{agentes}}{conj(placa)}%
  [estaAgente($a, as$)]
  {$res \igobs$ conMismasSanciones($a, as$)}%
  [$\Theta(1)$]
  [Devuelve el conjunto de agentes que tienen la misma cantidad de sanciones que el agente $a$]

  \InterfazFuncion{ConKSanciones}{\In{k}{nat}, \In{as}{agentes}}{conj(placa)}%
  [true]
  {$res \igobs$ conKSanciones($k, as$)}%
  [O(N$a$) la primera vez, O(log(N$a$)) en siguientes llamadas mientras no ocurran sanciones.]
  [Devuelve el conjunto de agentes que tienen exactamente $k$ sanciones. N$a$ es la cantidad de agentes definidos en $as$]


\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación de los Agentes}

  \begin{Estructura}{agentes}[estr]
    \begin{Tupla}[estr]
      \tupItem{as}{DiccRapido(datos)}%
      \tupItem{masVig}{nat}%
      \tupItem{huboSanciones}{bool}%
      \tupItem{mismSanciones}{lista(conj(nat))}%
      \tupItem{kSanciones}{Arreglo(tuplaK)}%
    \end{Tupla}

    \begin{Tupla}[datos]
      \tupItem{sanciones}{nat}%
      \tupItem{pos}{posicion}%
      \tupItem{capturas}{nat}%
      \tupItem{conMismSanciones}{itLista(conj(nat))}%
    \end{Tupla}

    \begin{Tupla}[tuplaK]
      \tupItem{sanciones}{nat}%
      \tupItem{placa}{nat}%
    \end{Tupla}

    \begin{Tupla}[posicion]
      \tupItem{fila}{nat}%
      \tupItem{columna}{nat}%
    \end{Tupla}

    {\small La idea de la lista enlazada mismSanciones es que guarde en cada posicion a todos aquellos agentes que comparten sanciones, con rapido acceso gracias al Iterador en los datos del agente. El arreglo kSanciones se utiliza para ordenar a los agentes por su cantidad de sanciones en tiempo O(N), y poder buscar a alguno con $K$ sanciones en O(log(N)) para acceder a aquellos que tienen la misma cantidad via mismSanciones}


  \end{Estructura}

  Invariante de representacion en castellano:
  \begin{enumerate}
  
  \item masVigilante esta definido en agentes.
  \item masVigilante es el agente con menor numero de placa entre aquellos que tienen mas capturas en el diccionario de agentes.
  \item Si no hubo sanciones ($\neg$huboSanciones), entonces el arreglo kSanciones representa fielmente a todos los agentes con sus respectivas sanciones segun el diccionario.
  \item Los agentes de la lista mismSanciones no estan repetidos, y son exactamente los definidos en diccionario de agentes.
  %\item No se repiten los agentes en conjuntos de distintos items de la lista.
  \item Para todo item de la lista mismSanciones, y para todo agente dentro del conjunto del item, la cantidad de sanciones es igual al resto del conjunto, y menor al de todos los agentes de items siguientes.
  
  \end{enumerate}

  \Rep[estr][e]{
  
  \begin{enumerate}
  \item def?(e.masVigilante, e.as) $\yluego$
  \item (($\forall$ $a$ : nat) def?($a$, e.as) $\impluego$ (obtener($a$, e.as).capturas $=$ obtener(e.masVigilante, e.as).capturas $\land$ $a$ $>$ e.masVigilante) $\lor$ (obtener($a$, e.as).capturas $<$ obtener(e.masVigilante, e.as).capturas) $\lor$ ($a$ $=$ e.masVigilante)) $\land$
  \item ($\neg$(e.huboSanciones) $\implies$ CorrespondenSanciones(e) $\land$ SancionesOrdenadas(e) $\land$ PlacasValidas(e)) $\land$
  \item ( \ (($\forall$ $i$ : nat) $i <$ Longitud(e.mismSanciones) $\impluego$ MSDefinidosEnDicc(e,$i$)) $\land$ DiccDefinidosEnMSYNoRepetidos(e) \ ) $\yluego$
  \item ( \ ($\forall$ $i$ : nat) ($i <$ Longitud(e.mismSanciones) $\impluego$ MSTieneMismSanciones(e, $i$)) $\land$ \\ ($i <$ (Longitud(e.mismSanciones) $- 1$) $\impluego$ MSCadaItemTieneDifSanciones(e,$i$)) \ )
  \end{enumerate}
  
  }\mbox{}
  {Reemplazos sintacticos: }
  ~      
  % \tadOperacion{CorrespondenSanciones}{estr/e}{bool}{}
  \tadAxioma{CorrespondenSanciones($e$)}{($\forall$ $i$ : nat) $i$ $<$ Tam(e.kSanciones) $\impluego$ e.kSanciones[$i$].sanciones $=$ obtener(e.kSanciones[$i$].placa, e.as).sanciones}
  ~      
  % \tadOperacion{SancionesOrdenadas}{estr/e}{bool}{}
  \tadAxioma{SancionesOrdenadas($e$)}{($\forall$ $i$ : nat) $i$ $<$ (Tam(e.kSanciones)$-1$) $\impluego$ e.kSanciones[$i$].sanciones $\leq$ e.kSanciones[$i+1$].sanciones}
  ~      
  % \tadOperacion{PlacasValidas}{estr/e}{bool}{}
  \tadAxioma{PlacasValidas($e$)}{($\forall$ $i$ : nat) $i$ $<$ Tam(e.kSanciones) $\impluego$ (($\forall$ $i'$ : nat) $i'$ $<$ Tam(e.kSanciones) $\land$ $\neg$($i = i'$) $\impluego$ $\neg$(e.kSanciones[$i$].placa = e.kSanciones[$i'$].placa))}
  ~      
  % \tadOperacion{MSDefinidosEnDicc}{estr/e, nat/i}{bool}{}
  \tadAxioma{MSDefinidosEnDicc($e$, $i$)}{($\forall$ $a$ : nat) En($a$, e.mismSanciones[$i$]) $\implies$ def?($a$, e.as)}
  ~      
  %\tadOperacion{DiccDefinidosEnMSYNoRepetidos}{estr/e}{bool}{}
  \tadAxioma{DiccDefinidosEnMSYNoRepetidos($e$)}{($\forall$ $a$ : nat) def?($a$, e.as) $\implies$ (($\exists!$ $i$ : nat) i $<$ Longitud(e.mismSanciones) $\impluego$ En($a$, e.mismSanciones[$i$]))}
  ~      
  %\tadOperacion{MSTieneMismSanciones}{estr/e, nat/i}{bool}{}
  \tadAxioma{MSTieneMismSanciones($e$, $i$)}{($\forall$ $a, a'$ : nat) (En($a$, e.mismSanciones[$i$]) $\land$ En($a'$, e.mismSanciones[$i$]) $\land$ $\neg$($a = a'$)) $\impluego$ obtener($a$, e.as) $=$ obtener($a'$, e.as)}
  ~      
  %\tadOperacion{MSCadaItemTieneDifSanciones}{estr/e, nat/i}{bool}{}
  \tadAxioma{MSCadaItemTieneDifSanciones($e$, $i$)}{($\forall$ $a, a'$ : nat) (En($a$, e.mismSanciones[$i$]) $\land$ En($a'$, e.mismSanciones[$i+1$])) $\impluego$ obtener($a$, e.as) $<$ obtener($a'$, e.as)}
  ~
  
  \AbsFc[estr]{agentes}[e]{c : agentes / \\
    ($\forall$ $p$ : pos) def?($p$, e.obstaculos) $\igobs$ ocupada?($p$, c) $\land$ 
    alto($c$) $\igobs$ e.alto $\land$
    ancho($c$) $\igobs$ e.ancho}

\end{Representacion}

  \begin{Algoritmos}

\textbf{Algoritmos de Campus}
  \listofalgorithms
    
  \begin{algorithm}[h]
    \text{$i$NuevoCampus(\In{al}{nat}, \In{an}{nat}) $\rightarrow$ res: estr}

    \Begin{
      res.computadoras $\leftarrow $ vacio() \hfill \textbf{//O(1)}\\
      res.mapa $\leftarrow $ vacia() \hfill \textbf{//O(1)}\\
      res.indexToString $\leftarrow $ vacia() \hfill \textbf{//O(1)}
    }
    \KwData{O(1)}

    \caption{NuevoCampus}    
  \end{algorithm}

  \begin{algorithm}[h]
    \text{$i$AgregarObstaculo(\In{p}{pos}, \Inout{e}{estr})}

    \Begin{
      Colocar($p$, $true$, e.obstaculos) \hfill \textbf{//O(1)}
    }
    \KwData{O(1)}

    \caption{AgregarObstaculo}
  \end{algorithm}

  \end{Algoritmos}


\end{document}
