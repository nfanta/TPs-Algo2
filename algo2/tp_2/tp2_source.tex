\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage[]{algorithm2e}

\SetKwInput{KwData}{Complejidad}
\SetAlgorithmName{Algoritmo}{Algoritmo}{Lista de algoritmos}
\SetAlCapSkip{1em}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

\section{Módulo Campus Seguro}


\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{Campus Seguro}

  \textbf{géneros}: \TipoVariable{campseg}

  \Titulo{Operaciones básicas de Campus Seguro}

  \InterfazFuncion{NuevoCampus}{\In{C}{campus}, \In{dA}{dicc(Ag$X$ pos)}}{campseg}%
  [($\forall $a$ \in Agente $) (def?(a,dA)  $\implicaluego$ (PosValida?(obtener(a,dA)) $\land$ $\neg$ ocupada?(obtener(a,dA),c) $\land$ ($\forall $a_{0},a_{1}$ \in Agente $) (def?(a_{0},dA) $\land$ def?(a_{1},dA) $\implicaluego$ obtener((a_{0},dA)) !$\equal$ obtener((a_{1},dA))] 
  {$res \igobs$ comenzarRastrillaje(c,dA)}%
  [$\Theta(1)$ -poner todos los agentes en el hash O(Na) y asignar campus O(1) ]
  [Crea un nuevo campus seguro con un campus y un diccionario de agentes, posicion]

  \InterfazFuncion{ingresarEstudiante}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
  [$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
  {$c$ $\igobs$ ingresarEstudiante($e, p, c_{0}$)}
  [La complejidad es agregarlo a estudiantes o hippies y sancionar a los que corresponda O(*long e*)]
  [Ingresa un estudiante en una posicion valida]
  []

  \InterfazFuncion{ingresarHippie}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
  [$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
  {$c$ $\igobs$ ingresarHippie($e, p, c_{0}$)}
  [La complejidad es agregarlo a estudiantes o hippies y sancionar a los que corresponda O(*long e*)]
  [Ingresa un hippie en una posicion valida]
  []



  \InterfazFuncion{moverEstudiantes}{\In{e}{nombre},\In{d}{dir},\Inout{c}{campseg}}{}
  [e $\in$ (estudiantes($c$) $\land$ (seRetira(e,d,c) $\or$ posValida?(proxPosicion(posEstudianteYHippie(e,c),d,campus(c)),campus(c)) $\land$ $\neg$ estaOcupada?(proxPosicion(posEstudianteYHippie(e,c),d,campus(c)),campus(c),c) $\land$ $c \igobs c_{0}$ ]
  {$c \igobs$ moverEstudiante(e,d,$c_{0}$)}
  [Complejidad longitud del nombre!]
  [Muevo un estudiante!]
  []

  \InterfazFuncion{moverHippie}{\In{h}{nombre},\Inout{c}{campseg}}{}
  [h $\in$ (hippie($c$) $\land$ $\neg$ todasOcupadas?(vecinos(posEstudianteHippie(h,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
  {$c \igobs$ moverHippie(h,$c_{0}$}
  [Complejidad longitud del nombre! mas la cantidad de estudiantes]
  [Muevo un hippie]
  []


  \InterfazFuncion{moverAgente}{\In{a}{agente},\Inout{c}{campseg}}{}
  [a $\in$ (agentes($c$) $\luego$ cantSanciones(a,c) $\leq$ 3 $\land$  $\neg$ todasOcupadas?(vecinos(posAgente(a,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
  {$c \igobs$ moverAgente(a, $c_{0}$)}
  []
  [Muevo un agente que no esta con mas de 3 sanciones]
  []

  \InterfazFuncion{campus}{\In{c}{campseg}}{campus}
  [true]
  {$res \igobs$ campus(c)}
  [$\Theta(1)$]
  [Devuelvo una referencia a campus]
  []

  \InterfazFuncion{estudiantes}{\In{c}{campseg}}{Itconj}
  [true]
  {$res \igobs$ crearIT(estudiantes(c))}
  [$\Theta(1)$]
  [Devuelvo un iterador a conjunto.]
  []

   \InterfazFuncion{hippies}{\In{c}{campseg}}{Itconj}
  [true]
  {$res \igobs$ crearIT(hippies(c))}
  [$\Theta(1)$]
  [Devuelvo un iterador a conjunto.]
  []

   \InterfazFuncion{agentes}{\In{c}{campseg}}{Itconj}
  [true]
  {$res \igobs$ crearIT(agentes(c))}
  [$\Theta(1)$]
  [Devuelvo un iterador a conjunto.]
  []

 \InterfazFuncion{posEstudianteYHippies}{\In{n}{nombre},\In{c}{campseg}}{pos}
  [(n $\in$ (estudiantes($c$) \ U \ hippies($c$))]
  {$res \igobs$ posEstudianteYHippies(n,c)}
  [$\Theta(longitud del input)$]
  [Pregunto por la posicion de un estudiante o hippie]
  []

 \InterfazFuncion{posAgente}{\In{a}{agente},\In{c}{campseg}}{pos}
  [(a $\in$ agentes($c$)]
  {$res \igobs$ posAgente(a,c)}
  [$\Theta(1)$]
  [Pregunto por la posicion de un agente]
  []

  \InterfazFuncion{cantSanciones}{\In{a}{agente},\In{c}{campseg}}{nat}
  [(a $\in$ agentes($c$)]
  {$res \igobs$ cantSanciones(a,c)}
  [$\Theta(1)$]
  [Pregunto por la cant de sanciones de un agente]
  []

    \InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente},\In{c}{campseg}}{nat}
  [(a $\in$ agentes($c$)]
  {$res \igobs$ cantHippiesAtrapados(a,c)}
  [$\Theta(1)$]
  [Pregunto por la cant de hippies atrapados de un agente]
  []

 \InterfazFuncion{cantHippies}{\In{c}{campseg}}{nat}
  [true]
  {$res \igobs$ cantHippies(c)}
  []
  [Pregunto por la cant de hippies]
  []

   \InterfazFuncion{cantEstudiantes}{\In{c}{campseg}}{nat}
  [true]
  {$res \igobs$ cantEstudiantes(c)}
  []
  [Pregunto por la cant de estudiantes]
  []

  \InterfazFuncion{masVigilante}{\In{c}{campseg}}{agente}
  [true]
  {$res \igobs$ masVigilante(c)}
  []
  [Pregunto por la cant de estudiantes]
  []

   \InterfazFuncion{conMismasSanciones}{\In{a}{agente},\In{c}{campseg}}{conj(agentes)}
  [(a $\in$ agentes($c$)]
  {$res \igobs$ conMismasSanciones(c)}
  [tiene que ser O(1) en caso promedio]
  [Devuelve al conj de agentes con la misma cantidad de sanciones]
  []

  \InterfazFuncion{conKSanciones}{\In{k}{nat},\In{c}{campseg}}{conj(agentes)}
  [true]
  {$res \igobs$ conKSanciones(c)}
  []
  [Devuelve al conj de agentes con k sanciones]
  []

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación del Campus Seguro}

  \begin{Estructura}{Campus Seguro}[estr]
    \begin{Tupla}[estr]
      \tupItem{campus}{Campus}%
      \tupItem{HipYEst}{HippiesYEstudiantes}%
      \tupItem{agentes}{Agentes}%
      \tupItem{posOcupadasHippies}{Matriz(nombre)}%
      \tupItem{posOcupadasEstudiantes}{Matriz(nombre)}%
      \tupItem{posOcupadasAgentes}{Matriz(placa)}%
    \end{Tupla}

    \begin{Tupla}[pos]
      \tupItem{fila}{nat}%
      \tupItem{columna}{nat}%
    \end{Tupla}
  \end{Estructura}

  Invariante de representacion en castellano:
  \begin{enumerate}
  
  \item Para toda $p$ de tipo $pos$, si $p$ esta definida en obstaculos, entonces tanto la fila como la columna de $p$ son menores o iguales a $alto$ y $ancho$ respectivamente.
  
  \end{enumerate}

  \Rep[estr][e]{
  
  \begin{enumerate}
  \item ($\forall$ $p$ : pos) $p$ $\in$ claves(e.obstaculos) $\implies$ ( p.fila $\leq$ c.alto $\land$ p.columna $\leq$ c.ancho )
  \end{enumerate}
  
  }\mbox{}

  \AbsFc[estr]{campus}[e]{c : campus / \\
    ($\forall$ $p$ : pos) def?($p$, e.obstaculos) $\igobs$ ocupada?($p$, c) $\land$ 
    alto($c$) $\igobs$ e.alto $\land$
    ancho($c$) $\igobs$ e.ancho}

\end{Representacion}

  \begin{Algoritmos}

\textbf{Algoritmos de Campus}
  \listofalgorithms
    
  \begin{algorithm}[h]
    \text{$i$NuevoCampus(\In{al}{nat}, \In{an}{nat}) $\rightarrow$ res: estr}

    \Begin{
      res.computadoras $\leftarrow $ vacio() \hfill \textbf{//O(1)}\\
      res.mapa $\leftarrow $ vacia() \hfill \textbf{//O(1)}\\
      res.indexToString $\leftarrow $ vacia() \hfill \textbf{//O(1)}
    }
    \KwData{O(1)}

    \caption{NuevoCampus}    
  \end{algorithm}

  \begin{algorithm}[h]
    \text{$i$AgregarObstaculo(\In{p}{pos}, \Inout{e}{estr})}

    \Begin{
      Colocar($p$, $true$, e.obstaculos) \hfill \textbf{//O(1)}
    }
    \KwData{O(1)}

    \caption{AgregarObstaculo}
  \end{algorithm}

  \end{Algoritmos}

\end{document}