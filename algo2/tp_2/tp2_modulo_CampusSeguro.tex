\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage[]{algorithm2e}
\SetKwInput{KwData}{Complejidad}
\SetKwInput{KwComm}{Comentarios}
\SetKwInput{KwExp}{Explicacion}
\SetKw{ret}{return}
\SetAlgorithmName{Algoritmo}{Algoritmo}{Lista de algoritmos}
\SetAlCapSkip{1em}
\newcommand{\moduloNombre}[1]{\textbf{#1}}
 
\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}
 
\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}
 
\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
\textbf{Pre} $\equiv$ \{#4\}\\%
\textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}
 
\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}
 
\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}
 
\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}
 
 
\newcommand{\Titulo}[1]{
\vspace*{1ex}\par\noindent\textbf{\large #1}\par
}
 
\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%
 
\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}
 
\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}
 
\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%
 
\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%
 
\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%
 
\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%
 
 
\newcommand{\DRef}{\ensuremath{\rightarrow}}
 
\begin{document}
 
 
\section{Modulo Campus Seguro}
\begin{Interfaz}
 
\textbf{se explica con}: \tadNombre{Campus Seguro}
 
\textbf{generos}: \TipoVariable{campseg}
 
\Titulo{Operaciones basicas de Campus Seguro}
 
\InterfazFuncion{NuevoCampus}{\In{C}{campus}, \In{dA}{dicc(Ag, pos)}}{campseg}%
 [($\forall$ a $\in$ Agentes ) \ (def?(a,dA) $\impluego$  (PosValida?(obtener(a,dA)) $\land$  $\neg$ ocupada?(obtener(a,dA),c) $\land$ ($\forall$ $a_{0}$ , $a_{1}$ $\in$ Agente ) (def?$a_{0}$,dA) $\land$ def?($a_{1}$,dA)$\impluego$ obtener(($a_{0}$,dA)) !$=$ obtener($a_{1}$,dA))]
{res $\igobs$ comenzarRastrillaje(c,dA)}
[O(Na + (alto * ancho))]
[Crea un nuevo campus seguro con un campus y un diccionario de agentes, posicion]
 
\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
[$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
{$c$ $\igobs$ ingresarEstudiante($e, p, c_{0}$)}
[O(|n$_{m}$|)]
[Ingresa un estudiante en una posicion valida]
 
\InterfazFuncion{ingresarHippie}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
[$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
{$c$ $\igobs$ ingresarHippie($e, p, c_{0}$)}
[O(|n$_{m}$|)]
{Ingresa un hippie en una posicion valida}  
 
\InterfazFuncion{moverEstudiantes}{\In{e}{nombre},\In{d}{dir},\Inout{c}{campseg}}{}
[e $\in$ (estudiantes($c$) $\land$ (seRetira(e,d,c) $\lor$ \\ 
posValida?(proxPosicion(posHippieYEstudiante(e,c),d,campus(c)),campus(c)) $\land$ \\ 
$\neg$ estaOcupada?(proxPosicion(posHippieYEstudiante(e,c),d,campus(c)),campus(c),c) $\land$ $c \igobs c_{0}$ ]
{$c \igobs$ moverEstudiante(e,d,$c_{0}$)}
[O(|n$_{m}$|)]
[Muevo un estudiante!]
 
 
\InterfazFuncion{moverHippie}{\In{h}{nombre},\Inout{c}{campseg}}{}
[h $\in$ (hippie($c$) $\land$ $\neg$ todasOcupadas?(vecinos(posEstudianteHippie(h,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
{$c \igobs$ moverHippie(h,$c_{0}$}
[O((cant(estudiantes)) + |n$_{m}$|)]
[Muevo un hippie]
 
 
\InterfazFuncion{moverAgente}{\In{a}{agente},\Inout{c}{campseg}}{}
[a $\in$ (agentes($c$) $\impluego$ cantSanciones(a,c) $\leq$ 3 $\land$  $\neg$ todasOcupadas?(vecinos(posAgente(a,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
{$c \igobs$ moverAgente(a, $c_{0}$)}
[O(cant(Hip) + |n$_{m}$|)]
[Muevo un agente que no esta con mas de 3 sanciones]
 
 
\InterfazFuncion{campus}{\In{c}{campseg}}{campus}
[true]
{$res \igobs$ campus(c)}
[$\Theta(1)$]
[Devuelvo una referencia a campus]
[]

\InterfazFuncion{estudiantes}{\In{c}{campseg}}{Itconj}
[true]
{$res \igobs$ crearIT(estudiantes(c))}
[$\Theta(1)$]
[Devuelvo un iterador a conjunto.]  
[]

\InterfazFuncion{hippies}{\In{c}{campseg}}{Itconj}
[true]
{$res \igobs$ crearIT(hippies(c))}
[$\Theta(1)$]
[Devuelvo un iterador a conjunto.]
[]

\InterfazFuncion{agentes}{\In{c}{campseg}}{Itconj}
[true]
{$res \igobs$ crearIT(agentes(c))}
[$\Theta(1)$]
[Devuelvo un iterador a conjunto]
 
\InterfazFuncion{posHippieYEstudiantes}{\In{n}{nombre},\In{c}{campseg}}{pos}
[(n $\in$ (estudiantes($c$) \ U \ hippies($c$))]
{$res \igobs$ posHippieYEstudiantes(n,c)}
[$\Theta(longitud del input)$]
[Pregunto por la posicion de un estudiante o hippie]
[]

\InterfazFuncion{posAgente}{\In{a}{agente},\In{c}{campseg}}{pos}
[(a $\in$ agentes($c$)]
{$res \igobs$ posAgente(a,c)}
[$\Theta(1)$ en caso promedio]
[Pregunto por la posicion de un agente]
 
\InterfazFuncion{cantSanciones}{\In{a}{agente},\In{c}{campseg}}{nat}
[(a $\in$ agentes($c$)]
{$res \igobs$ cantSanciones(a,c)}
[$\Theta(1)$ en caso promedio]
[Pregunto por la cant de sanciones de un agente]
 
 
\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente},\In{c}{campseg}}{nat}
[(a $\in$ agentes($c$)]
{$res \igobs$ cantHippiesAtrapados(a,c)}
[$\Theta(1)$ en caso promedio]
[Pregunto por la cant de hippies atrapados de un agente]
 
 
\InterfazFuncion{cantHippies}{\In{c}{campseg}}{nat}
[true]
{$res \igobs$ cantHippies(c)}
[O(1)]
[Pregunto por la cant de hippies]
 
\InterfazFuncion{cantEstudiantes}{\In{c}{campseg}}{nat}
[true]
{$res \igobs$ cantEstudiantes(c)}
[O(1)]
[Pregunto por la cant de estudiantes]
 
\InterfazFuncion{masVigilante}{\In{c}{campseg}}{agente}
[true]
{$res \igobs$ masVigilante(c)}
[O(1)]
[Pregunto por la cant de estudiantes]
 
 
\InterfazFuncion{conMismasSanciones}{\In{a}{agente},\In{c}{campseg}}{conj(agentes)}
[(a $\in$ agentes($c$)]
{$res \igobs$ conMismasSanciones(c)}
[O(1) en caso promedio]
[Devuelve al conj de agentes con la misma cantidad de sanciones]
 
 
\InterfazFuncion{conKSanciones}{\In{k}{nat},\In{c}{campseg}}{conj(agentes)}
[true]
{$res \igobs$ conKSanciones(c)}
[O(cant Agentes) la primera vez que se llama y O(log(cant Agentes) los otras veces que se llama mientras no ocurran sanciones)]
[Devuelve al conj de agentes con k sanciones]
 
 
\end{Interfaz}
 
\begin{Representacion}
 
\Titulo{Representacion del Campus Seguro}
\begin{Estructura}{Campus Seguro}[estr]
 \begin{Tupla}[estr]
  \tupItem{campus}{Campus}%
      \tupItem{HipYEst}{HippiesYEstudiantes}%
      \tupItem{agentes}{Agentes}%
      \tupItem{posOcupadasHippies}{Matriz(nombre)}%
      \tupItem{posOcupadasEstudiantes}{Matriz(nombre)}%
      \tupItem{posOcupadasAgentes}{Matriz(placa)}%
   \end{Tupla}
\end{Estructura}
//
Invariante de representacion en castellano:
\begin{enumerate}
 
\item Una posicion en posOcupada no puede estar ocupada por el resto de las matrices de posOcupadas  al mismo tiempo (En otras palabras la interseccion del conj de pos definidas en posOcupadasHippies, posOcupadasEstudiantes y posOcupadasAgentes es vacia.
\item La dimension de las matrices posOcupadasHippies/Estudiantes/Agentes tiene que coincidir con el $alto$ y $ancho$ del $campus$.
\item Para todo nombre que este definido en HipYEst la posicion de ese nombre tiene que estar definida en posOcupadasHippies ó(excluyente) en posOcupadasEstudiantes.
\item Para toda placa que este definida en Agentes la posicion de esa placa tiene que estar definida en posOcupadasAgentes.
\item Para toda pos definida en posOcupadasEstudiantes o posOcupadasHippies existe un nombre tal que si esta definido darme la pos de ese nombre es igual a la primera
\item Para toda pos definida en posOcupadasAgentes Existe una placa tal que posAgente de esa placa es igual a la pos definida en posOcupas(es decir todas las pos en poscupadasAgentes tienen un placa asociada en Agentes).
\item Los obstaculos del campus no pueden estar definidos en posOcupadasHippie/Estudiante/Agente.
\item No existe una pos definida en posOcupadasHippie  tal que los vecinos de esa pos esten todos definidos en posOcupadaEstudiante.
\item No existe una pos definida en posOcupadasHippie  tal que que este bloqueada por al menos un agente.
 
\end{enumerate}
 
 
 
 
\Rep[estr][e]{
 
\begin{enumerate}
 
\item (($\forall$ $p$ : pos) def?(p,e.posOcupadaHippie) $\implies$ $\neg$ def?(p,e.posOcupadaEstudiante) $\land$ $\neg$ def?(p,e.posOcupadaAgente)) $\land$ (($\forall$ $p$ : pos) def?(p,e.posOcupadaEstudiante) $\implies$ $\neg$ def?(p,e.posOcupadaHippie) $\land$ $\neg$ def?(p,e.posOcupadaAgente)) (($\forall$ $p$ : pos) def?(p,e.posOcupadaAgente) $\implies$ $\neg$ def?(p,e.posOcupadaEstudiante) $\land$ $\neg$ def?(p,e.posOcupadaHippie))
\item Alto($campus$) $\igobs$ alto(e.posOcupadasHippie) $\land$ Alto(e.$campus$) $\igobs$ alto(e.posOcupadasEstudiante) $\land$ Alto(e.$campus$) $\igobs$ alto(e.posOcupadasAgente) $\land$ Ancho(e.$campus$) $\igobs$ ancho(e.posOcupadasHippie) $\land$ Ancho(e.$campus$) $\igobs$ ancho(e.posOcupadasEstudiante) $\land$ Ancho(e.$campus$) $\igobs$ ancho(e.posOcupadasAgente)
\item ($\forall$ $n$ : nombre) def?(n,e.HipYEst) $\impluego$ def?(posHippieYEstudiante(obtener(n,e.HipYEst)),e.posOcupadaHippie) $\oplus$ def?(posHippieYEstudiante(obtener(n,e.HipYEst)),e.posOcupadaEstudiante)
\item ($\forall$ $pl$ : placa) def?(pl,e.agentes)  $\impluego$ def?(posAgente(obtener(n,e.agente)),e.posOcupadaAgente)
\item ($\forall$ $p$ : pos) (def?(p,e.posOcupadaHippie) $\lor$ def?(p,e.posOcupadaEstudiante)) $\implies$ (($\exists$ n : nombre) def?(n,e.HipYEst) $\impluego$ posEstudianteHippie(obtener(n,e,e.HipYEst)) $=$ p)
\item ($\forall$ $p$ : pos) (def?(p,e.posOcupadaAgente) $\implies$ (($\exists$ pl : placa) def?(pl,e.agentes) $\impluego$ posAgente(obtener(pl,e.agentes)) $=$ p)
\item ($\forall$ $p$ : pos) p $\in$ obstaculos(e.campus) $\implies$  $\neg$ def?(p,e.posOcupadasHippie) $\land$ $\neg$ def?(p,e.posOcupadasEstudiante) $\land$ $\neg$ def?(p,e.posOcupadasAgente)
\item ($\forall$ $p$ : pos) def?(p,e.posOcupadasHippie) $\impluego$ $\neg$ ( ($\forall$ $po$ : pos)  vecinos(p,e.campus) $\implies$ def?(po,e.posOcupadasEstudiante) )
\item ($\forall$ $p$ : pos) def?(p,e.posOcupadasHippie) $\impluego$ $\neg$ ( (($\forall$ $po$ : pos) po $\in$ vecinos(p,e.campus) $\land$ estaOcuapada(po,e)) $\implies$ ($\exists$ p1: pos) def?(p1,e.posOcupadasAgentes) $\land$ p1 = p0))
 
\end{enumerate}
 
}\mbox{}  
 
\AbsFc[estr]{campusSeguro}[e]{c : campusSeguro / \\
 e.campus $\igobs$ campus(c) $\land$ \\
 Estudiantes(e.HipYEst) $\igobs$ estudiantes(c) $\land$ \\
 Hippies(e.HipYEst) $\igobs$ hippies(c) $\land$ \\
 Agentes(e.agentes) $\igobs$ agentes(c) $\land$ \\
 ($\forall$ n : nombre) (Esta?(n, e.HipYEst)) $\impluego$ (posHippieYEstudiante(n, c) $\igobs$ posHippieYEstudiante(n, e.HipYEst)) $\land$ \\
 ($\forall$ a : placa) (a $\in$ Agentes?(e.agentes)) $\impluego$ (\\
 (PosAgente(a, e.agentes) $\igobs$ posAgente(a, c)) $\land$ \\
 (SancionesAgente(a, e.agentes) $\igobs$ cantSanciones(a, c)) $\land$ \\
 (CapturasAgente(a, e.agentes) $\igobs$ cantHippiesAtrapados(a, c)) \ )}
\end{Representacion}
 
\newpage

\begin{Algoritmos}
\textbf{Algoritmos de Campus Seguro}

\listofalgorithms

\newpage
 
\begin{algorithm}[h]
 \text{$i$NuevoCampus(\In{c}{campus}, \In{dA}{dicc(agente,pos)}) $\rightarrow$ res: estr}
 
 \Begin{
   res.campus $\leftarrow $ c \hfill \textbf{//O(1)}\\
   res.agentes $\leftarrow $ nuevoAgentes(dA) \hfill \textbf{//O(nA)}\\
   matrizAgentes $\leftarrow $ nuevaMatriz(c.alto,c.ancho)\hfill \textbf{//O(c.alto *c.ancho)}\\
   ITagentes $\leftarrow $ crearIT(agentes?(res.agentes))\hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){haymas(ITagentes)}{
   definir(actual(ITagentes),posAgentes(actual(ITagentes),res.agentes),matrizAgentes)\hfill \textbf{//O(1) + O(1)(caso Promedio)}\\
   siguiente(ITagente)\hfill \textbf{//O(1)}\\
    }
   res.PosOcupadasAgente $\leftarrow $ matrizAgente \hfill \textbf{//O(1)}\\%ACLARAR QUE ES POR REFERENCIA ENTONCES ES O(1)?
   res.PosOcupadasHippie $\leftarrow $ crearMatriz(c.alto,c.ancho) \hfill \textbf{//O(c.alto *c.ancho))}\\%
   res.PosOcupadasEstudiante $\leftarrow $ crearMatriz(c.alto,c.ancho) \hfill \textbf{//O(c.alto *c.ancho)}\\%
   res.HipYEst $\leftarrow $ nuevoHipYEst() \hfill \textbf{//O(1)}\\
 }
 \KwData{O(nA)+ 3 * O( alto * ancho) = O(nA+  alto* ancho)) nA= Cantiadd de agentes y Alto y ancho las dimensiones del campus. }
 
 \caption{NuevoCampus}    
\end{algorithm}
 

\begin{algorithm}[H]
 \text{$i$ingresarEstudiante(\In{n}{nombre},\In{p}{pos}, \Inout{e}{estr})}
 
 \Begin
 {
 
   \eIf(\hfill \textbf{//O(1)}){iEstudianteHippieficado(p,n)}
   {
     definirHippie(n,p,e.HipYEst)\hfill \textbf{//O(|n$_{m}$|)}\\
     definir(p,n,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
     cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
     {
       \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie)}
       {
         \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e))}
         {
             borrar(obtener(actual(Itvec),e.posOcupadasHippie),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}
         }
       }
       \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasEstudiante)}
       {
         \If(\hfill \textbf{//O(1)}){estudianteHippieficado(actual(Itvec),e))}
           {
             hippificar(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|))}
           }
         \If(\hfill \textbf{//O(1)}){estudianteSancionar(acltual(Itvec),e)}
           {
             sancionar(actual(Itvec),e) \hfill \textbf{//O(1) en caso promedio}
           }
       }
       siguiente(ItVec) \hfill \textbf{//O(1)}
     }
       
   }%CAMBIAAAAAAAAAR CS POR E
      {
   definirEstudiante(e,p,e.HipYEst)\hfill \textbf{//O(|n$_{m}$|)}\\
   definir(p,e,e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
   {
     \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasHippie))}
     {
       \If(\hfill \textbf{//O(1)}){hippieRodeadoEst(actual(Itvec),e)}
         {
         transformarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}
         }
         \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
         {
         eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}
         }
     }
     \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
     {
       \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
       {
       sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio!}
       }
     }
   siguiente(Itvec) \hfill \textbf{//O(1)}
   }
 }
 
   \If(\hfill \textbf{//O(1)}){estudianteSancionar(p,e)}
   {
     cjtoVec $\leftarrow$ vecinos(p,cs.campus) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
     {
       \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasAgente))}
       {
         agregarSancion(obtener((actual(Itvec),e),e.posOcupadasAgente),e.Agente) \hfill \textbf{//O(1) En caso promedio!}
       }
       siguiente(Itvec) \hfill \textbf{//O(1)}
     }
   
 }
 }
 \KwData{Teniendo en cuenta el caso promedio que involucra todas las operaciones con agentes la complejidad que me queda es entrando por cualquier rama del if en el peor caso 3*|n$_{m}$| = O(|n$_{m}$|)}

 
 \caption{IngresarEstudiante}
\end{algorithm}    
 
 
\begin{algorithm}[H]
\text{$i$ingresarHippie(\In{h}{nombre},\In{p}{pos}, \Inout{e}{estr})}
 
\Begin{
 \If(\hfill \textbf{//O(1)}){hippieCapturado(p,cs)}
 {
 sumarCapturas(p,e) \hfill \textbf{//O(1) En caso promedio}
 }
 \eIf(\hfill \textbf{//O(1)}){hippieRodeadoEst(p,e)}
 {
   definirEstudiante(h,p,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
   definir(p,h,e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
     {
     \If(\hfill \textbf{//O(1)}){estudianteSancionar((actual(Itvec),e))}
       {
         sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}\\
       }
       siguiente(Itvec) \hfill \textbf{//O(1)}
     }
 }{
 definirHippie(h,p,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|))}\\
 definir(p,h,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
 \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie))}
   {
   \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
     {
       eliminarHippie (actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|))}\\
     }
 
   }
 \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
   {
   \If(\hfill \textbf{//O(1) + O(1)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
     {
     sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(1) En caso Promedio}\\
     borrar(obtener((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
     borrar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
     }
     \If(\hfill \textbf{//O(1)}){estudianteHippieficado(actual(Itvec),e)}
     {
       hippificar(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|))}\\
     }
     \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
     {
       sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso Promedio!}\\
     }
   }  
 siguiente(Itvec) \hfill \textbf{//O(1)}
 }
}
 
}
\KwData{Teniendo en cuenta el caso promedio que involucra todas las operaciones con agentes la complejidad que me queda es de: \\ si defino como estudiante tengo O(|n$_{m}$|) mas las posibles sanciones a los agentes pero en el peor caso si lo defino como hippie tengo que verificar  todos mis vecinos para ver como los afecto si tengo que transformarlos a hippies o si provoco que un hippie sea eliminado por lo tanto tengo 3*|n$_{m}$| mas el acceso a los agentes = O(|n$_{m}$|)}
\KwComm{Ingreso un hippie teniendo en cuenta todos los casos que pueden pasar.}
 
\caption{ingresarHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$moverEstudiante(\In{n}{nombre},\In{d}{dir}, \Inout{e}{estr})}
 
\Begin{
 pose $\leftarrow$ posHippieYEstudiante(n,e) \hfill \textbf{//O(|n$_{m}$|)}\\
 proxpos $\leftarrow$ proxPosicion(pose,d) \hfill \textbf{//O(1)}\\
 \eIf(\hfill \textbf{//O(1)}){meVoy(pose,d,e.campus)}
 {
   borrar(n,e,HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
   borrar(pose,e.PosOcupadasEstudiante) \hfill \textbf{//O(1)}\\
 
 }
    %ELSE
    {
   muevoEstudiante(n,pose,dir,e) \hfill \textbf{//O(|n$_{m}$|)}\\
   posNueva $\leftarrow$ posHippieYEstudiante(n,e) \hfill \textbf{//O(|n$_{m}$|)}\\
   \eIf(\hfill \textbf{//O(1)}){estudianteHippieficado(posNueva,e)}
   {
     hippificar(posNueva,e) \hfill \textbf{//O(|n$_{m}$|)}\\
     cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
     {
       \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie))}
       {
         \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
         {
           eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}\\
         }
       }
       \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasEstudiante))}
       {
         \If(\hfill \textbf{//O(1) + O(1)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
         {
           sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}\\
           borrar(obtener((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
           borrar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
         }
         \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
         {
           sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}\\%COMPLEEEEEEEEEEEEEEEEEEEEEEEEEEEEEETAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR
         }
       }
     
       siguiente(Itvec) \hfill \textbf{//O(1)}\\
     }
   }
      %ELSE
      {
     cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
     {
       \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasHippie))}
         {
           \If(\hfill \textbf{//O(1)}){hippieRodeadoEst(actual(Itvec),e)}
           {
           transformarHippie((actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}\\
           }
           \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
           {
             eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}\\
           }
         }
       \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasEstudiante))}
         {
           \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
           {
             sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}
           }
         }
         siguiente(ItVec) \hfill \textbf{//O(1)}
       }
   }
 }
 
 
}
\KwData{Teniendo en cuenta el caso promedio que involucra todas las operaciones con agentes la complejidad que me queda es de: En el peor de los casos si el estudiante que muevo no se va del campus y ademas se convierte en hippie tengo 2*|n$_{m}$| + 4*|n$_{m}$|(de transformarlo en hippie mas que en el peor de los casos tengo que eliminar hippies) = 6* |n$_{m}$| = O(|n$_{m}$|) las otras ramas del if no contemplarian el peor caso.}
\KwComm{}
 
\caption{moverEstudiante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$moverHippie(\In{h}{nombre}, \Inout{e}{estr})}
 
\Begin{
 posh $\leftarrow$ posHippieYEstudiante(h,e) \hfill \textbf{//O(|n$_{m}$|))}\\
 posDestino $\leftarrow$ estMasCercano(posh,e) \hfill \textbf{//O($cant estudiantes$)}\\
 muevoHippie(posh,posDestino,e) \hfill \textbf{//O(|n$_{m}$|)}\\
 posNueva $\leftarrow$ posHippieYEstudiante(h,e) \hfill \textbf{//O(|n$_{m}$|)}
 cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie))}
     {
       \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
       {
         eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}\\
       }
     }
     \If(\hfill \textbf{//O(1))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
     {
       \If(\hfill \textbf{//O(1) + O(1)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
       {
        sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}\\
        borrarEstudiante(quineEs?((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
        borrar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
       }
       \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
         {
           sancionar(actual(Itvec),e) \hfill \textbf{//O(1) En caso promedio}\\
         }
     }
   siguiente(Itvec) \hfill \textbf{//O(1)}\\
 }
 
}
\KwData{Teniendo en cuenta el caso promedio que involucra todas las operaciones con agentes la complejidad que me queda es de:  ya un O($cant estudiantes$) para saber a donde me tengo que mover o(k*|n$_{m}$|) con k cte, que involucra cambiar mi poscion y/o elimiar,modificar a mis vecinos por mi movimiento, entonces tengo O(cant est + k*|n$_{m}$|) sacando las cte me queda O(cant est + |n$_{m}$|)}
\KwComm{}
 
\caption{moverHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$moverAgente(\In{a}{agente}, \Inout{e}{estr})}
 
\Begin{
 posa $\leftarrow$ posAgente(a,e.agente) \hfill \textbf{//O(1) En caso promedio}\\
 posDestino $\leftarrow$ hipMasCercano(posh,e) \hfill \textbf{//O(cant hippies)}\\
 muevoAgente(posh,posDestino,e) \hfill \textbf{//O(1) En caso promedio}\\
 posNueva $\leftarrow$ posAgente(a,e.agente) \hfill \textbf{//O(1) En caso promedio}
 cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie))}
     {
       \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
       {
         eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(|n$_{m}$|)}\\
       }
     }
     \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasEstudiante))}
     {
     
       \If(\hfill \textbf{//O(1)}){estudianteSancionar(actual(Itvec),e)}
         {
           sancionar(actual(Itvec),e) \hfill \textbf{//O(1) en caso promedio}\\
         }
     }
   siguiente(Itvec) \hfill \textbf{//O(1)}\\
 }
 
}
\KwData{Teniendo en cuenta el caso promedio que involucra todas las operaciones con agentes la complejidad que me queda es de: O(cant hip) (para saber a donde me tengo que mover) + 3*O(|n$_{m}$|) que involucra borrar a los hippies que encerre que a lo sumo pueden ser 3. Entonces la complejidad me queda sacando todas las constantes O((cant hip)+ |n$_{m}$|)}
\KwComm{}
 
\caption{moverAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$campus(\In{e}{estr}) $\rightarrow$ c: $\&$campus}
 
\Begin{
 
 res $\leftarrow$ e.campus
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo un campus por referencia}
 
\caption{campus}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$estudiantes(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
\Begin{
 
 res $\leftarrow$ crearIt(*Estudiantes(e.HipYEst)) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo un iterador}
 
\caption{estudiantes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$agentes(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
\Begin{
 
 res $\leftarrow$ crearIt(*Agentes(e.agentes)) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo un iterador}
 
\caption{agentes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$hippies(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
\Begin{
 
 res $\leftarrow$ crearIt(*Hippies(e.HipYEst)) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo un iterador}
 
\caption{hippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$posEstundianteYHippie(\In{n}{nombre},\In{e}{estr}) $\rightarrow$ p: pos}
 
\Begin{
 
 res $\leftarrow$ posEstundianteHippie(n,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
 \ret{res}
}
\KwData{$O(|n_{m}|)$}
\KwComm{Devuelvo una poss}
 
\caption{posEstundianteYHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$posAgente(\In{a}{agente},\In{e}{estr}) $\rightarrow$ p: pos}
 
\Begin{
 
 res $\leftarrow$ posAgente(a,e.Agentes) \hfill \textbf{//O(1) en caso Promedio}\\
 \ret{res}
}
\KwData{$O(1)$ en caso promedio}
\KwComm{Devuelvo una poss de un agente}
 
\caption{posAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$cantSanciones(\In{a}{agente},\In{e}{estr}) $\rightarrow$ k: nat}
 
\Begin{
 
 res $\leftarrow$ sancionesAgentes(a,e.Agentes) \hfill \textbf{//O(1) en caso promedio}\\
 \ret{res}
}
\KwData{$O(1)$ en caso promedio}
\KwComm{Cantidad de sanciones de un agente}
 
\caption{cantSanciones}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$masVigilante(\In{e}{estr}) $\rightarrow$ a: agente}
 
\Begin{
 
 res $\leftarrow$ masVigilante(e.Agentes) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$ }
\KwComm{Devulvo a un agente donde agenete es un placa, del mas vigilante}
 
\caption{masVigilante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$conMismasSancioens(\In{a}{agente},\In{e}{estr}) $\rightarrow$ cA: conj(agente)}
 
\Begin{
 
 res $\leftarrow$ conMismasSanciones(a,e.Agentes) \hfill \textbf{//O(1) en caso promedio}\\
 \ret{res}
}
\KwData{$O(1)$ en caso promedio}
\KwComm{Devulvo a un conj(agente) donde agente es un placa, y todos los del cjto tienen las mismas sanciones}
 
\caption{conMismasSanciones}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip%%%%%FIJARSE QUE MIERDA DEVUELVE SI ES UNA REFERENCIA O QUE
 
\begin{algorithm}[H]
\text{$i$conKsanciones(\In{k}{nat},\In{e}{estr}) $\rightarrow$ cA: conj(agente)}
 
\Begin{
 
 res $\leftarrow$ conKSanciones(k,e.Agentes)
 \ret{res}
}
\KwData{$O(cant Agentes)$ la primera vez que se llama y $O(Log(cant Agentes))$ las siguientes veces que se llama mientras no se produzcan sanciones)}
\KwComm{Devulvo a un conj(agente) donde agenete es un placa, y el conj son todos los agentes con k sanciones}
 
\caption{conkSanciones}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip%%%%%FIJARSE QUE MIERDA DEVUELVE SI ES UNA REFERENCIA O QUE
 
\begin{algorithm}[H]
\text{$i$cantHippiesAtrapados(\In{a}{agente},\In{e}{estr}) $\rightarrow$ n: nat}
 
\Begin{
 
 res $\leftarrow$ cantHippiesAtrapados(a,e.Agentes) \hfill \textbf{//O(1) en caso promedio}\\
 \ret{res}
}
\KwData{$O(1)$ En caso promedio}
\KwComm{Devuelvo la cantidad de hippies atrapados por un agente en particular}
 
\caption{cantHippiesAtrapados}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$cantHippies(\In{e}{estr}) $\rightarrow$ n: nat}
 
\Begin{
 
 res $\leftarrow$ cardinal(*Hippies(e.HipYEst)) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo la cantidad de hippies}
 
\caption{cantHippies}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$cantEstudiantes(\In{e}{estr}) $\rightarrow$ n: nat}
 
\Begin{
 
 res $\leftarrow$ cardinal(*Estudiantes(e.HipYEst)) \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{Devuelvo la cantidad de estudiantes}
 
\caption{cantEstudiantes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
%%%%%%%%%%%%%%%%%%%%%%%
%% AUXILIAEREEEEEEES %%
%%%%%%%%%%%%%%%%%%%%%%%
 
 
 
 
\begin{algorithm}[H]
\text{$i$hippieRodeadoEst(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 cantEst $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasEstudiante))}
   {
   cantEst++ \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 res $\leftarrow$ cantEst = cardinal(cjtoVec) \hfill \textbf{//O(cant elementos)}
 
 \ret{res}
}
\KwData{ Es $O(1)$ porque la cantidad de elementos en cjtoVec es cte.}
\KwComm{me fijo si estoy rodeado por estudiantes}
 
\caption{hippieRodeadoEst}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
\begin{algorithm}[H]
\text{$i$hippieCapturado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 alMenos1Ag $\leftarrow$ false \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasAgente))}
   {
   alMenos1Ag $\leftarrow$ true \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 res $\leftarrow$ alMenos1Ag $\land$ bloqueado(p,e) \hfill \textbf{//O(1)}
 
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{me fijo si me pueden capturar}
 
\caption{hippieCapturado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$estudianteHippieficado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 cantHip $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){ocupada?(actual(Itvec),e.posOcupadasHippie))}
   {
   cantHip++ \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 res $\leftarrow$ cantHip $\geq$ 2 \hfill \textbf{//O(1)}\\
 
 \ret{res}
}
\KwData{$O(1)$ Como la cantaidad de pos a chequear es constante, es decir a lo sumo puedo tener 4 vecinos, la complejidad queda O(1)}
\KwComm{me fijo si 2 vecinos mios son hippies como para atraerme al hippismo}
 
\caption{estudianteHippieficado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$estudianteSancionar(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 alMenos1Ag $\leftarrow$ false \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){definida?(actual(Itvec),e.posOcupadasAgente))}
   {
   alMenos1Ag $\leftarrow$ true \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 res $\leftarrow$ alMenos1Ag $\land$ bloqueado(p,e) \hfill \textbf{//O(1)}
 
 \ret{res}
}
\KwData{$O(1)$ Me fijo si uno de mis vecinos me estan bloquenado y al menos tengo un agente como solo accedo una cantidad finita a una matriz es $O(1)$ }
\KwComm{me fijo si un agente me esta bloqueando}
 
\caption{estudianteSancionar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$bloqueado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 cosasBloqueando $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){(def?(actual(Itvec),e.posOcupadasAgente) $\lor$ def?(actual(Itvec),e.posOcupadasHippie)) $\lor$ def?(actual(Itvec),e.posOcupadasEstudiante)) $\lor$ def?(actual(Itvec),obstaculos(e.campus)))}
   {
   cosasBloqueado++ \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 res $\leftarrow$ cosasBloqueado $=$ cardinal(cjtoVec) \hfill \textbf{//O(1)}
 
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{me fijo si estoy bloqueado}
 
\caption{bloqueado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$hippificar(\In{p}{pos},\Inout{e}{estr})}
 
\Begin{
 
 definirHippie(obener(pos,e.posOcupadasEstudiante)),pos,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
 definir(pos,obener(pos,e.posOcupadasEstudiante)),e.posOcupadasHippie) \hfill \textbf{//O(1) + O(1)}\\
 borrar(obener(pos,e.posOcupadasEstudiante)),e.HipYEst) \hfill \textbf{//O(|n$_{m}$| + O(1)}\\
 borrar(pos,e.posOcupadasEstudiante) \hfill \textbf{//O(1)}
}
\KwData{2*O(|n$_{m}$|) = O(|n$_{m}$|)}
\KwComm{transformo un estudiante a hippie}
 
\caption{hippificar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$sancionar(\In{p}{pos},\Inout{e}{estr})}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasAgente))}
   {
     agregarSancion(obtener(actual(Itvec),e.posOcupadasAgente),e.agentes) \hfill \textbf{//O(1) En caso promedio}
   }
 }
}
\KwData{$O(1)$ En caso promedio ya que sabemos que las placas de los agentes estan distribuidas uniformemente}
\KwComm{sanciono agentes}
 
\caption{sancionar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$transformarHippie(\In{p}{pos},\Inout{e}{estr})}
 
\Begin {
 
 definirEstudiante(obener(pos,e.posOcupadasHippie)),pos,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
 definir(pos,obener(pos,e.posOcupadasHippie)),e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
 borrar(obener(pos,e.posOcupadasHippie)),e.HipYEst) \hfill \textbf{//O(|$n_{m}$|)}\\
 eliminar(pos,e.posOcupadasHippie) \hfill \textbf{//O(1)}
}
\KwData{$2*O(|n_{m}|) = O(|n_{m}|)$}
\KwComm{transformo un hippie a estudiante}
 
\caption{transformarHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$sumarCapturas(\In{p}{pos},\Inout{e}{estr})}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasAgente))}
   {
     agregarCaptura(obtener(actual(Itvec),e.posOcupadasAgente),e.agentes) \hfill \textbf{//O(1) En caso Promedio}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
}
\KwData{$O(1)$ En caso promedio ya que sabemos que las placas estan distribuidas uniformemente y ademas como el cjtovec es cte el ciclo tambien es O(1)}
\KwComm{Agrego las capturas a los agentes que participaron}
 
\caption{sumarCapturas}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$eliminarHippie(\In{p}{pos},\Inout{e}{estr})}
 
\Begin{
 
 sumarCapturas(p,e) \hfill \textbf{//O(1) En caso promedio}\\
 borrar(obener(pos,e.posOcupadasHippie)),e.HipYEst) \hfill \textbf{//O($n_{m}$)}\\
 eliminar(pos,e.posOcupadasHippie) \hfill \textbf{//O(1)}
}
\KwData{Tomando el caso promedio de agregar sancion en peor caso me quedaria O($n_{m}$)}
\KwComm{Elimino un hippie y agrego las capturas a los agentes que participaron de la matanza}
 
\caption{eliminarHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
\text{$i$meVoy(\In{p}{pos},\In{d}{dir},\In{e}{estr})}
 
\Begin{
 
 res $\leftarrow$ ((ingresoSuperior(p,e.campus) $\land$ d = Arriba) $\lor$ (ingresoInferior(p,e.campus) $\land$ d = Abajo)) \hfill \textbf{//O(1)+O(1)}
}
\KwData{O(1)}
\KwComm{Me fijo si me voy del campus!}
 
\caption{meVoy}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
\begin{algorithm}[H]
\text{$i$estMasCercano(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
\Begin{
\If(\hfill \textbf{//O(1)}){cantEst(e) $!=$0}
{
 cjtoPosEst $\leftarrow$ claves(e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
 ItposEst $\leftarrow$ crearIT(cjtoPosEst) \hfill \textbf{//O(1)}\\
 posMasCercana $\leftarrow$ actual(ItposEst) \hfill \textbf{//O(1)}\\
 siguiente(ItposEst) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(ItposEst)}{
   \If(\hfill \textbf{//O(1)}){ distancia(p,posMasCercana) $\geq$ distancia(p,actual(ItposEst))}
     {
       posMasCercana $\leftarrow$ actual(ItposEst) \hfill \textbf{//O(1)} \\
     }
     siguiente(ItposEst) \hfill \textbf{//O(1)} \\
 }
 
 res $\leftarrow$ posMasCercana \hfill \textbf{//O(1)}\\
}
{
 res $\leftarrow$ actual(crearIT(ingresoMasCercano(e.campus)) \hfill \textbf{//O(1)}
}
 
}
\KwData{$O(cant estudiantes)$ que esta acotado por el ancho y alto del campus ya que no puede existir 2 fichas en un mismo casillero }
\KwComm{Me devuelvo la poss mas cercana entre los estudiantes si no hay devuelvo un ingreso total la funcion de mover lo va a filtrar}
 
\caption{estMasCercano}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$hipMasCercano(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
\Begin{
\eIf(\hfill \textbf{//O(1)}){cantHip(e) $!=$0}
 {
   cjtoPosHip $\leftarrow$ claves(e.posOcupadasHippie) \hfill \textbf{//O(cant hippies)}\\
   ItposHip $\leftarrow$ crearIT(cjtoPosHip) \hfill \textbf{//O(1)}\\
   posMasCercana $\leftarrow$ actual(Itpoship) \hfill \textbf{//O(1)}\\
   siguiente(ItposHip) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(ItposHip)}{
     \If(\hfill \textbf{//O(1)}){ distancia(p,posMasCercana) $\geq$ distancia(p,actual(ItposHip))}
       {
         posMasCercana $\leftarrow$ actual(Itpoship) \hfill \textbf{//O(1)} \\
       }
       siguiente(ItposHip) \hfill \textbf{//O(1)} \\
   }
 
   res $\leftarrow$ posMasCercana \hfill \textbf{//O(1)}\\
   }
 {
 
  res $\leftarrow$ actual(crearIT(ingresoMasCercano(e.campus)) \hfill \textbf{//O(1)}
 
 }
}
\KwData{$O(cant hippies)$}
\KwComm{Me devuelvo la poss mas cercana entre los hippies}
 
\caption{hipMasCercano}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$muevoEstudiante(\In{n}{nombre},\In{p}{pos},\In{d}{dir},\Inout{e}{estr})}
 
\Begin{
 
posVieja $\leftarrow$ pos \hfill \textbf{//O(1)}\\
posNueva $\leftarrow$ proxPosicion(d,posVieja) \hfill \textbf{//O(1)}\\
definirEstudiante(n,posNueva,e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
definir(posNueval,n,e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
borrar(posViejar,e.posOcupadasEstudiante) \hfill \textbf{//O(1)}\\
 
}
\KwData{O(|n$_{m}$|)}
\KwComm{Me muevo a la pos que me da la direccion}
 
\caption{muevoEstudiante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
 
 
 
\begin{algorithm}[H]
\text{$i$muevoHippie(\In{p}{pos},\In{pD}{pos},\Inout{e}{estr})}
 
\Begin{
 
nombrehip $\leftarrow$ obtener(p,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
 \If(\hfill \textbf{//O(1)}){cantEst(e) $!=$ 0}
 {
 
   \eIf(\hfill \textbf{//O(1)}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e)) }
   {
     definirHippie(nombreHip,damePoslibre(p,e),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
     definir(damePoslibre(p,e),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
     borrar(damePoslibre(p,e),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
   }
   {
   
     definirHippie(nombreHip,proxPosicion(p,dameDireccion(p,posD),e.HipYEst) \hfill \textbf{//O(|n$_{m}$|)}\\
     definir(proxPosicion(p,dameDireccion(p,posD),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
     borrar(proxPosicion(p,dameDireccion(p,posD),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(1)}\\
   }
 
 }
 
}
\KwData{O(|n$_{m}$|)}
\KwComm{Muevo un hippie al estudiante mas cercano.}
 
\caption{muevoHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$muevoAgente(\In{p}{pos},\In{pD}{pos},\Inout{e}{estr})}
 
\Begin{
 
nombreAg $\leftarrow$ obtener(p,e.posOcupadasAg) \hfill \textbf{//O(1)}\\
 \eIf(\hfill \textbf{//O(1)}){cantHip(e) $!=$ 0}
 {
 
   \eIf(\hfill \textbf{//O(1)}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e)) }
   {
     cambiarPosicion(nombreAg,damePoslibre(p,e),e.agentes) \hfill \textbf{//O(1) En caso promedio}\\
     definir(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
     borrar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
   }
   {
   
     cambiarPosicion(nombreAg,proxPosicion(p,dameDireccion(p,posD),e.agentes) \hfill \textbf{//O(1) En caso promedio}\\
     definir(proxPosicion(p,dameDireccion(p,posD),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
     borrar(proxPosicion(p,dameDireccion(p,posD),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
   }
 
 }
 {
   posIngreso $\leftarrow$ actual(crearIT(ingresosMasCercanos(e.campus))) \hfill \textbf{//O(1)}\\
   \eIf(\hfill \textbf{//O(1)}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e))}
   {
     cambiarPosicion(nombreAg,damePoslibre(p,e),e.agentes) \hfill \textbf{//O(1) En caso promedio}\\
     definir(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
     borrar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
 
   }
   {
     cambiarPosicion(nombreAg,proxPosicion(p,dameDireccion(p,posIngreso),e.agentes) \hfill \textbf{//O(1) En caso promedio}\\
     definir(proxPosicion(p,dameDireccion(p,posIngreso),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
     borrar(proxPosicion(p,dameDireccion(p,posIngreso),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(1)}\\
 
   }
 
 }  
}
\KwData{En caso promedio, sabiendo que las placas estan distribuidas uniformemente, es O(1), si no es O(n$_{a}$)}
\KwComm{muevo un agente al hippie mas cercano si esta bloqueada la poss me muevo a una cualquier si no me muevo a la correcta, si no hay hippies me muevo al ingreso mas cercano\\ con la misma metodologia que al moverme a un hippie }
 
\caption{moverAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$estaOcupado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
\Begin{
 
   res $\leftarrow$ (def?(pos,e.posOcupadasAgente) $\lor$ def?(pos,e.posOcupadasHippie)) $\lor$ def?(pos,e.posOcupadasEstudiante)) $\lor$ Ocupada?(pos, e.campus))
   \hfill \textbf{//O(1)}\\
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{me fijo si existe alguien en esa poss}
 
\caption{estaOcupado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$damePosLibre(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
\Begin{
 cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
 Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
 \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
 {
   \If(\hfill \textbf{//O(1)}){estaOcupado(actual(Itvec),e))}
   {
   res $\leftarrow$ actual(Itvec) \hfill \textbf{//O(1)}
   }
   siguiente(Itvec) \hfill \textbf{//O(1)}
 }
 
 \ret{res}
}
\KwData{$O(1)$}
\KwComm{devuelvo Una poss libre de mis vecinos}
 
\caption{damePosLibre}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
\text{$i$dameDireccion(\In{p}{pos},\In{pD}{estr}) $\rightarrow$ res: dir}
 
\Begin{
  var dirFinal : dir \hfill \textbf{//O(1)}
  \eIf(\hfill \textbf{//O(1)}){|p.x - pD.x| $\geq$ |p.y - pD.y|}
    {
      \eIf(\hfill \textbf{//O(1)}){p.x $>$ pD.x}
      {
        dirFinal $\leftarrow$ Izquierda \hfill \textbf{//O(1)}
      }
      {
        dirFinal $\leftarrow$ Derecha \hfill \textbf{//O(1)}
      }
    }
    {
      \eIf(\hfill \textbf{//O(1)}){p.y $>$ pD.y}
      {
        dirFinal $\leftarrow$ Abajo \hfill \textbf{//O(1)}
      }
      {
        dirFinal $\leftarrow$ Arriba \hfill \textbf{//O(1)}
      }
    }
 
  res $\leftarrow$ dirFinal \hfill \textbf{//O(1)}
}
\KwData{$O(1)$}
\KwComm{devuelvo la direccion a la cual debo ir}
 
\caption{dameDirrecion}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\end{Algoritmos}
 
\end{document}