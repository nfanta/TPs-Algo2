\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage[]{algorithm2e}
\SetKwInput{KwData}{Complejidad}
\SetKwInput{KwComm}{Comentarios}
\SetKwInput{KwExp}{Explicacion}
\SetKw{ret}{return}
\SetAlgorithmName{Algoritmo}{Algoritmo}{Lista de algoritmos}
\SetAlCapSkip{1em}
\newcommand{\moduloNombre}[1]{\textbf{#1}}
 
\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}
 
\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}
 
\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
 \textbf{Pre} $\equiv$ \{#4\}\\%
 \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}
 
\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}
 
\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}
 
\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}
 
 
\newcommand{\Titulo}[1]{
 \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}
 
\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%
 
\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}
 
\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}
 
\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%
 
\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%
 
\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%
 
\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%
 
 
\newcommand{\DRef}{\ensuremath{\rightarrow}}
 
\begin{document}
 
 
\section{Mdulo Campus Seguro}
\begin{Interfaz}
 
 \textbf{se explica con}: \tadNombre{Campus Seguro}
 
 \textbf{generos}: \TipoVariable{campseg}
 
 \Titulo{Operaciones basicas de Campus Seguro}
 
\InterfazFuncion{NuevoCampus}{\In{C}{campus}, \In{dA}{dicc(Ag$X$ pos)}}{campseg}%
 [($\forall$ a $\in$ Agentes ) \ (def?(a,dA) $\impluego$  (PosValida?(obtener(a,dA)) $\land$  $\neg$ ocupada?(obtener(a,dA),c) $\land$ ($\forall$ $a_{0}$ , $a_{1}$ $\in$ Agente ) (def?$a_{0}$,dA) $\land$ def?($a_{1}$,dA)$\impluego$ obtener(($a_{0}$,dA)) !$=$ obtener($a_{1}$,dA))]
{res $\igobs$ comenzarRastrillaje(c,dA)}
 [O(Na) y asignar campus O(1) ]
{$Crea un nuevo campus seguro con un campus y un diccionario de agentes, posicion$}
 
\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
 [$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
 {$c$ $\igobs$ ingresarEstudiante($e, p, c_{0}$)}
 [La complejidad es agregarlo a estudiantes o hippies y sancionar a los que corresponda O(*long e*)]
 {Ingresa un estudiante en una posicion valida}
 
\InterfazFuncion{ingresarHippie}{\In{e}{nombre},\In{p}{pos} , \Inout{c}{campseg}}{}
 [$\neg$ (e $\in$ (estudiantes($c$) \ U \ hippies($c$))) $\land$  esIngreso?($p, campus(c)$) $\land$ \ $\neg$ estaOcupada?(p,c) \ $\land$ \ $c \igobs c_{0}$ ]
 {$c$ $\igobs$ ingresarHippie($e, p, c_{0}$)}
 [La complejidad es agregarlo a estudiantes o hippies y sancionar a los que corresponda O(*long e*)]
 {Ingresa un hippie en una posicion valida}  
 
\InterfazFuncion{moverEstudiantes}{\In{e}{nombre},\In{d}{dir},\Inout{c}{campseg}}{}
 [e $\in$ (estudiantes($c$) $\land$ (seRetira(e,d,c) $\lor$ posValida?(proxPosicion(posEstudianteYHippie(e,c),d,campus(c)),campus(c)) $\land$ $\neg$ estaOcupada?(proxPosicion(posEstudianteYHippie(e,c),d,campus(c)),campus(c),c) $\land$ $c \igobs c_{0}$ ]
 {$c \igobs$ moverEstudiante(e,d,$c_{0}$)}
 [Complejidad longitud del nombre!]
 {Muevo un estudiante!}
 
 
\InterfazFuncion{moverHippie}{\In{h}{nombre},\Inout{c}{campseg}}{}
 [h $\in$ (hippie($c$) $\land$ $\neg$ todasOcupadas?(vecinos(posEstudianteHippie(h,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
 {$c \igobs$ moverHippie(h,$c_{0}$}
 [Complejidad longitud del nombre! mas la cantidad de estudiantes]
 {Muevo un hippie}
 
 
\InterfazFuncion{moverAgente}{\In{a}{agente},\Inout{c}{campseg}}{}
 [a $\in$ (agentes($c$) $\impluego$ cantSanciones(a,c) $\leq$ 3 $\land$  $\neg$ todasOcupadas?(vecinos(posAgente(a,c),campus(c),c)) $\land$ $c \igobs c_{0}$]
 {$c \igobs$ moverAgente(a, $c_{0}$)}
 [O(Long de nombre) y O(Cant Hip)]
 {Muevo un agente que no esta con mas de 3 sanciones}
 
 
\InterfazFuncion{campus}{\In{c}{campseg}}{campus}
 [true]
 {$res \igobs$ campus(c)}
 [$\Theta(1)$]
 {Devuelvo una referencia a campus}
 []
 
\InterfazFuncion{estudiantes}{\In{c}{campseg}}{Itconj}
 [true]
 {$res \igobs$ crearIT(estudiantes(c))}
 [$\Theta(1)$]
 {Devuelvo un iterador a conjunto.}  
 []
 
\InterfazFuncion{hippies}{\In{c}{campseg}}{Itconj}
 [true]
 {$res \igobs$ crearIT(hippies(c))}
 [$\Theta(1)$]
 {Devuelvo un iterador a conjunto.}
 []
\InterfazFuncion{agentes}{\In{c}{campseg}}{Itconj}
 [true]
 {$res \igobs$ crearIT(agentes(c))}
 [$\Theta(1)$]
 {Devuelvo un iterador a conjunto}
 
\InterfazFuncion{posEstudianteYHippies}{\In{n}{nombre},\In{c}{campseg}}{pos}
 [(n $\in$ (estudiantes($c$) \ U \ hippies($c$))]
 {$res \igobs$ posEstudianteYHippies(n,c)}
 [$\Theta(longitud del input)$]
 {Pregunto por la posicion de un estudiante o hippie}
 []
 
 
\InterfazFuncion{posAgente}{\In{a}{agente},\In{c}{campseg}}{pos}
 [(a $\in$ agentes($c$)]
 {$res \igobs$ posAgente(a,c)}
 [$\Theta(1)$]
 {Pregunto por la posicion de un agente}
 
 
 
\InterfazFuncion{cantSanciones}{\In{a}{agente},\In{c}{campseg}}{nat}
 [(a $\in$ agentes($c$)]
 {$res \igobs$ cantSanciones(a,c)}
 [$\Theta(1)$]
 {Pregunto por la cant de sanciones de un agente}
 
 
\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente},\In{c}{campseg}}{nat}
 [(a $\in$ agentes($c$)]
 {$res \igobs$ cantHippiesAtrapados(a,c)}
 [$\Theta(1)$]
 {Pregunto por la cant de hippies atrapados de un agente}
 
 
\InterfazFuncion{cantHippies}{\In{c}{campseg}}{nat}
 [true]
 {$res \igobs$ cantHippies(c)}
 []
 {Pregunto por la cant de hippies}
 
\InterfazFuncion{cantEstudiantes}{\In{c}{campseg}}{nat}
 [true]
 {$res \igobs$ cantEstudiantes(c)}
 []
 {Pregunto por la cant de estudiantes}
 
\InterfazFuncion{masVigilante}{\In{c}{campseg}}{agente}
 [true]
 {$res \igobs$ masVigilante(c)}
 []
 {Pregunto por la cant de estudiantes}
 
 
\InterfazFuncion{conMismasSanciones}{\In{a}{agente},\In{c}{campseg}}{conj(agentes)}
 [(a $\in$ agentes($c$)]
 {$res \igobs$ conMismasSanciones(c)}
 [tiene que ser O(1) en caso promedio]
 {Devuelve al conj de agentes con la misma cantidad de sanciones}
 
 
\InterfazFuncion{conKSanciones}{\In{k}{nat},\In{c}{campseg}}{conj(agentes)}
 [true]
 {$res \igobs$ conKSanciones(c)}
 []
{Devuelve al conj de agentes con k sanciones}
 
 
\end{Interfaz}
 
\begin{Representacion}
 
 \Titulo{Representacion del Campus Seguro}
\begin{Estructura}{Campus Seguro}[estr]
   \begin{Tupla}[estr]
    \tupItem{campus}{Campus}%
      \tupItem{HipYEst}{HippiesYEstudiantes}%
      \tupItem{agentes}{Agentes}%
      \tupItem{posOcupadasHippies}{Matriz(nombre)}%
      \tupItem{posOcupadasEstudiantes}{Matriz(nombre)}%
      \tupItem{posOcupadasAgentes}{Matriz(placa)}%
   \end{Tupla}
 \end{Estructura}
  //
  Invariante de representacion en castellano:
 \begin{enumerate}
 
 \item Una posicion en posOcupada no puede estar ocupada por el resto de las matrices de posOcupadas  al mismo tiempo (En otras palabras la interseccion del conj de pos definidas en posOcupadasHippies, posOcupadasEstudiantes y posOcupadasAgentes es vacia.
 \item La dimension de las matrices posOcupadasHippies/Estudiantes/Agentes tiene que coincidir con el $alto$ y $ancho$ del $campus$.
 \item Para todo nombre que este definido en HipYEst la posicion de ese nombre tiene que estar definida en posOcupadasHippies ó(excluyente) en posOcupadasEstudiantes.
 \item Para toda placa que este definida en Agentes la posicion de esa placa tiene que estar definida en posOcupadasAgentes.
 \item Para toda pos definida en posOcupadasEstudiantes o posOcupadasHippies existe un nombre tal que si esta definido darme la pos de ese nombre es igual a la primera
 \item Para toda pos definida en posOcupadasAgentes Existe una placa tal que posAgente de esa placa es igual a la pos definida en posOcupas(es decir todas las pos en poscupadasAgentes tienen un placa asociada en Agentes).
 \item Los obstaculos del campus no pueden estar definidos en posOcupadasHippie/Estudiante/Agente.
 \item No existe una pos definida en posOcupadasHippie  tal que los vecinos de esa pos esten todos definidos en posOcupadaEstudiante.
 \item No existe una pos definida en posOcupadasHippie  tal que que este bloqueada por al menos un agente.
 
 \end{enumerate}
 
 

 
 \Rep[estr][e]{
 
  \begin{enumerate}
 
  \item (($\forall$ $p$ : pos) def?(p,e.posOcupadaHippie) $\implies$ $\neg$ def?(p,e.posOcupadaEstudiante) $\land$ $\neg$ def?(p,e.posOcupadaAgente)) $\land$ (($\forall$ $p$ : pos) def?(p,e.posOcupadaEstudiante) $\implies$ $\neg$ def?(p,e.posOcupadaHippie) $\land$ $\neg$ def?(p,e.posOcupadaAgente)) (($\forall$ $p$ : pos) def?(p,e.posOcupadaAgente) $\implies$ $\neg$ def?(p,e.posOcupadaEstudiante) $\land$ $\neg$ def?(p,e.posOcupadaHippie))
  \item Alto($campus$) $\igobs$ Fila(e.posOcupadasHippie) $\land$ Alto(e.$campus$) $\igobs$ Fila(e.posOcupadasEstudiante) $\land$ Alto(e.$campus$) $\igobs$ Fila(e.posOcupadasAgente) $\land$ Ancho(e.$campus$) $\igobs$ col(e.posOcupadasHippie) $\land$ Ancho(e.$campus$) $\igobs$ col(e.posOcupadasEstudiante) $\land$ Ancho(e.$campus$) $\igobs$ col(e.posOcupadasAgente)
  \item ($\forall$ $n$ : nombre) def?(n,e.HipYEst) $\impluego$ def?(posEstudianteYHippie(obtener(n,e.HipYEst)),e.posOcupadaHippie) $\oplus$ def?(posEstudianteYHippie(obtener(n,e.HipYEst)),e.posOcupadaEstudiante)
  \item ($\forall$ $pl$ : placa) def?(pl,e.agentes)  $\impluego$ def?(posAgente(obtener(n,e.agente)),e.posOcupadaAgente)
  \item ($\forall$ $p$ : pos) (def?(p,e.posOcupadaHippie) $\lor$ def?(p,e.posOcupadaEstudiante)) $\implies$ (($\exists$ n : nombre) def?(n,e.HipYEst) $\impluego$ posEstudianteHippie(obtener(n,e,e.HipYEst)) $=$ p)
  \item ($\forall$ $p$ : pos) (def?(p,e.posOcupadaAgente) $\implies$ (($\exists$ pl : placa) def?(pl,e.agentes) $\impluego$ posAgente(obtener(pl,e.agentes)) $=$ p)
  \item ($\forall$ $p$ : pos) p $\in$ obstaculos(e.campus) $\implies$  $\neg$ def?(p,e.posOcupadasHippie) $\land$ $\neg$ def?(p,e.posOcupadasEstudiante) $\land$ $\neg$ def?(p,e.posOcupadasAgente)
  \item $\neg$(($\exists  $ $p$ :pos) def?(p,e.posOcupadasHippie) $\impluego$  (($\forall$ $po$ : pos) po $\in$ vecinos(p,e.campus) $\implies$ def?(po,posOcuapasEstudiante)))
  \item $\neg$(($\exists  $ $p$ :pos) def?(p,e.posOcupadasHippie) $\impluego$  (($\forall$ $po$ : pos) Me falta decir este ultimo!!!!

  \end{enumerate}

 }\mbox{}  
 
 \AbsFc[estr]{campusSeguro}[e]{c : campusSeguro / \\
   e.campus $\igobs$ campus(c) $\land$ \\
   Estudiantes(e.HipYEst) $\igobs$ estudiantes(c) $\land$ \\
   Hippies(e.HipYEst) $\igobs$ hippies(c) $\land$ \\
   Agentes(e.agentes) $\igobs$ agentes(c) $\land$ \\
   ($\forall$ n : nombre) (Esta?(n, e.HipYEst)) $\impluego$ (posEstudianteYHippie(n, c) $\igobs$ PosEstudianteYHippie(n, e.HipYEst)) $\land$ \\
   ($\forall$ a : placa) (a $\in$ Agentes?(e.agentes)) $\impluego$ (\\
   (PosAgente(a, e.agentes) $\igobs$ posAgente(a, c)) $\land$ \\
   (SancionesAgente(a, e.agentes) $\igobs$ cantSanciones(a, c)) $\land$ \\
   (CapturasAgente(a, e.agentes) $\igobs$ cantHippiesAtrapados(a, c)) \ )}
\end{Representacion}
 
 \begin{Algoritmos}
\textbf{Algoritmos de Campus Seguro}
 \listofalgorithms
   
 \begin{algorithm}[h]
   \text{$i$NuevoCampus(\In{c}{campus}, \In{dA}{dicc(agente,pos)}) $\rightarrow$ res: estr}
 
   \Begin{
     res.campus $\leftarrow $ c \hfill \textbf{//O(1)}\\
     res.agentes $\leftarrow $ nuevoAgentes(dA) \hfill \textbf{//O(nuevoAgentes)}\\
     matrizAgentes $\leftarrow $ crearMatriz(c.alto,c.ancho)\hfill \textbf{//O(crearMatriz)}\\
     ITagentes $\leftarrow $ crearIT(agentes?(res.agentes))\hfill \textbf{//O(1) + O(agentes?)}\\
     \While(\hfill \textbf{//O(1)}){haymas(ITagentes)}{
     ocuparPos(actual(ITagentes),posAgentes(actual(ITagentes),res.agentes),matrizAgentes)\hfill \textbf{//O(ocuparPos) + O(posAgente)}\\
     siguiente(ITagente)\hfill \textbf{//O(1)}\\
      }
     res.PosOcupadasAgente $\leftarrow $ matrizAgente \hfill \textbf{//O(1)}\\%ACLARAR QUE ES POR REFERENCIA ENTONCES ES O(1)?
     res.PosOcupadasHippie $\leftarrow $ crearMatriz(c.alto,c.ancho) \hfill \textbf{//O(crearMatriz)}\\%
     res.PosOcupadasEstudiante $\leftarrow $ crearMatriz(c.alto,c.ancho) \hfill \textbf{//O(crearMatriz)}\\%
     res.HipYEst $\leftarrow $ nuevoHipYEst() \hfill \textbf{//O(1)}\\
   }
   \KwData{Completar}
 
   \caption{NuevoCampus}    
 \end{algorithm}
 
 
\begin{algorithm}[h]
   \text{$i$ingresarEstudiante(\In{e}{nombre},\In{p}{pos}, \Inout{e}{estr})}
 
   \Begin
   {
     \eIf(\hfill \textbf{//O(iEstudianteHippieficado)}){iEstudianteHippieficado(p,e)}
     {
       nombrarHippie(e,p,e.HipYEst)\hfill \textbf{//O(nombrarHippie)}\\
       ocupar(p,e,e.posOcupadasHippie) \hfill \textbf{//O(ocupar)}\\
       cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
       Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
       \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
       {
         \If(\hfill \textbf{//O(1)}){def?(actual(Itvec),e.posOcupadasHippie)}
         {
           \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(actual(Itvec),e))}
           {
               eliminarHippie(quienEs?(actual(Itvec),posOcupadasHippie),e) \hfill \textbf{//O(eliminarHippie) + O(quienEs?)}
           }
         }
         \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante)}
         {
           \If(\hfill \textbf{//O(estudianteHippieficado)}){estudianteHippieficado(actual(Itvec),e))}
             {
               hippificar(actual(Itvec),e) \hfill \textbf{//O(hippificar)}
             }
           \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(acltual(Itvec),e)}
             {
               sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}
             }
         }
         siguiente(ItVec) \hfill \textbf{//O(1)}
       }
           
     }%CAMBIAAAAAAAAAR CS POR E
      {
     nombrarEstudiante(e,p,e.HipYEst)\hfill \textbf{//O(nombrarEstudiante)}\\
     ocupar(p,e,e.posOcupadasEstudiante) \hfill \textbf{//O(ocupar)}\\
     cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
     {
       \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
       {
         \If(\hfill \textbf{//O(1)}){hippieRodeadoaEst(actual(Itvec),e)}
           {
           transformarHippie(actual(Itvec),e) \hfill \textbf{//O(transformarHippie)}
           }
           \If(\hfill \textbf{//O(1)}){hippieCapturado(actual(Itvec),e)}
           {
           eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}
           }
       }
       \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
       {
         \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
         {
         sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}
         }
       }
     siguiente(Itvec) \hfill \textbf{//O(1)}
     }
   }
 
     \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(p,e)}
     {
       cjtoVec $\leftarrow$ vecinos(p,cs.campus) \hfill \textbf{//O(1)}\\
       Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
       \While(\hfill \textbf{//O(1)}){haymas(Itvec)}
       {
         \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasAgente))}
         {
           agregarSancion(quienEs?((actual(Itvec),e),e.posOcupadasAgente),e.Agente) \hfill \textbf{//O(quienEs?) + O(agregarSancion)}
         }
         siguiente(Itvec) \hfill \textbf{//O(1)}
       }
     }
     
   }
   \KwData{COMPLETAAAAR}
   \KwComm{comentario}
 
   \caption{IngresarEstudiante}
 \end{algorithm}    
   
 
\begin{algorithm}[H]
 \text{$i$ingresarHippie(\In{h}{nombre},\In{p}{pos}, \Inout{e}{estr})}
 
 \Begin{
   \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(p,cs)}
   {
   sumarCapturas(p,e) \hfill \textbf{//O(sumarCapturas)}
   }
   \eIf(\hfill \textbf{//O(hippieRodeadoEst)}){hippieRodeadoEst(p,e)}
   {
     definirEstudiante(h,p,e.HipYEst) \hfill \textbf{//O(definirEstudiante)}\\
     ocupar(p,h,e.posOcupadasEstudiante) \hfill \textbf{//O(ocupar)}\\
     cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
     Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
     \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
       {
       \If(\hfill \textbf{//O(estudianteSanconar)}){estudianteSancionar((actual(Itvec),e))}
         {
           sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}\\
         }
         siguiente(Itvec) \hfill \textbf{//O(1)}
       }
   }{
   definirHippie(h,p,e.HipYEst) \hfill \textbf{//O(definirHippie)}\\
   ocupar(p,h,e.posOcupadasHippie) \hfill \textbf{//O(ocupar)}\\
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIt(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
   \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
     {
     \If(\hfill \textbf{//O(hippieAtrapado)}){hippieAtrapado(actual(Itvec),e)}
       {
         eliminarHippie (actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}\\
       }
 
     }
   \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
     {
     \If(\hfill \textbf{//O(estudianteHippieficado) + O(hippieCapturado)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
       {
       sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(sumarCapturas)}\\
       borrarEstudiante(quineEs?((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(quienEs?) + O(borrarEstudiante)}\\
       desOcupar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(desOcupar)}\\
       }
       \If(\hfill \textbf{//O(estudianteHippieficado)}){estudianteHippieficado(actual(Itvec),e)}
       {
         hippificar(actual(Itvec),e) \hfill \textbf{//O(hippificar)}\\
       }
       \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
       {
         sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}\\
       }
     }  
   siguiente(Itvec)
   }
}
   
 }
 \KwData{COMPLETAAAR}
 \KwComm{comentario}
 
 \caption{ingresarHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$moverEstudiante(\In{n}{nombre},\In{d}{dir}, \Inout{e}{estr})}
 
 \Begin{
   pose $\leftarrow$ posEstudianteYHippie(n,e) \hfill \textbf{//O(posEstudianteYHippie)}\\
   proxpos $\leftarrow$ proxPosicion(pose,d) \hfill \textbf{//O(proxPosicion)}\\
   \eIf(\hfill \textbf{//O(meVoy)}){meVoy(pose,d,e.campus)}
   {
     borrarEstudiante(n,e,HipYEst)\\
     desOcupar(pose,e.PosOcupadasEstudiante)\\
 
   }
    %ELSE
    {
     muevoEstudiante(n,pose,dir,e) \hfill \textbf{//O(muevoEstudiante)}\\
     posNueva $\leftarrow$ posEstudianteYHippie(n,e) \hfill \textbf{//O(posEstudianteYHippie)}\\
     \eIf(\hfill \textbf{//O(estudianteHippieficado)}){estudianteHippieficado(posNueva,e)}
     {
       hippificar(posNueva,e) \hfill \textbf{//O(hippificar)} \hfill \textbf{//O(hippificar)}\\
       cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(vecinos)}\\
       Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
       \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
       {
         \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
         {
           \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(actual(Itvec),e)}
           {
             eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}\\
           }
         }
         \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
         {
           \If(\hfill \textbf{//O(estudianteHippieficado) + O(hippieCapturado)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
           {
             sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(sumarCapturas)}\\
             borrarEstudiante(quineEs?((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(quienEs?) + O(borrarEstudiante)}\\
             desOcupar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(desOcupar)}\\
           }
           \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
           {
             sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}\\
           }
         }
         
         siguiente(Itvec) \hfill \textbf{//O(1)}\\
       }
     }
      %ELSE
      {
       cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(vecinos)}\\
       Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
       \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
       {
         \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
           {
             \If(\hfill \textbf{//O(hippieRodeadoEst)}){hippieRodeadoEst(actual(Itvec),e)}
             {
             transformarHippie((actual(Itvec),e) \hfill \textbf{//O(transformarHippie)}\\
             }
             \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(actual(Itvec),e)}
             {
               eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}\\
             }
           }
         \If(\hfill \textbf{//O(def?(matriz)}){def?(actual(Itvec),e.posOcupadasEstudiante))}
           {
             \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
             {
               sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}
             }
           }
           siguiente(ItVec)
         }
     }
   }
 
   
 }
 \KwData{COMPLETAR}
 \KwComm{comentario}
 
 \caption{moverEstudiante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$moverHippie(\In{h}{nombre}, \Inout{e}{estr})}
 
 \Begin{
   posh $\leftarrow$ posEstudianteYHippie(h,e) \hfill \textbf{//O(posEstudianteYHippie)}\\
   posDestino $\leftarrow$ estMasCercano(posh,e) \hfill \textbf{//O(estMasCercano)}\\
   muevoHippie(posh,posDestino,e) \hfill \textbf{//O(muevoHippie)}\\
   posNueva $\leftarrow$ posEstudianteYHippie(h,e) \hfill \textbf{//O(posEstudianteYHippie)}
   cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(vecinos)}\\
   Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
       {
         \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(actual(Itvec),e)}
         {
           eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}\\
         }
       }
       \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
       {
         \If(\hfill \textbf{//O(estudianteHippieficado) + O(hippieCapturado)}){estudianteHippieficado(actual(Itvec),e) $\land$ hippieCapturado(actual(Itvec),e)}
         {
          sumarCapturas(actual(Itvec),e) \hfill \textbf{//O(sumarCapturas)}\\
           borrarEstudiante(quineEs?((actual(Itvec),e),e.posOcupadasEstudiante),e.HipYEst) \hfill \textbf{//O(quienEs?) + O(borrarEstudiante)}\\
          desOcupar((actual(Itvec),e),e.posOcupadasEstudiante) \hfill \textbf{//O(desOcupar)}\\
         }
         \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
           {
             sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}\\
           }
       }
     siguiente(Itvec) \hfill \textbf{//O(1)}\\
   }
   
}
 \KwData{COMPLETAR}
 \KwComm{comentario}
 
 \caption{moverHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$moverAgente(\In{a}{agente}, \Inout{e}{estr})}
 
 \Begin{
   posa $\leftarrow$ posAgente(a,e.agente) \hfill \textbf{//O(posAgente)}\\
   posDestino $\leftarrow$ hipMasCercano(posh,e) \hfill \textbf{//O(hipMasCercano)}\\
   muevoAgente(posh,posDestino,e) \hfill \textbf{//O(muevoAgente)}\\
   posNueva $\leftarrow$ posAgente(a,e.agente) \hfill \textbf{//O(posAgente)}
   cjtovec $\leftarrow$ vecinos(posNueva,e) \hfill \textbf{//O(vecinos)}\\
   Itvec $\leftarrow$ crearIT(cjtovec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasHippie))}
       {
         \If(\hfill \textbf{//O(hippieCapturado)}){hippieCapturado(actual(Itvec),e)}
         {
           eliminarHippie(actual(Itvec),e) \hfill \textbf{//O(eliminarHippie)}\\
         }
       }
       \If(\hfill \textbf{//O(def?(matriz))}){def?(actual(Itvec),e.posOcupadasEstudiante))}
       {
         
         \If(\hfill \textbf{//O(estudianteSancionar)}){estudianteSancionar(actual(Itvec),e)}
           {
             sancionar(actual(Itvec),e) \hfill \textbf{//O(sancionar)}\\
           }
       }
     siguiente(Itvec) \hfill \textbf{//O(1)}\\
   }
   
}
 \KwData{COMPLETAR}
 \KwComm{comentario}
 
 \caption{moverAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$campus(\In{e}{estr}) $\rightarrow$ c: $\&$campus}
 
 \Begin{
   
   res $\leftarrow$ e.campus
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo un campus por referencia}
 
 \caption{campus}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$estudiantes(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
 \Begin{
   
   res $\leftarrow$ crearIt(*Estudiantes(e.HipYEst)) \hfill \textbf{//O(1)}
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo un iterador}
 
 \caption{estudiantes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$agentes(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
 \Begin{
   
   res $\leftarrow$ crearIt(*Agentes(e.agentes)) \hfill \textbf{//O(1)}
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo un iterador}
 
 \caption{agentes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$hippies(\In{e}{estr}) $\rightarrow$ it: Itconj}
 
 \Begin{
   
   res $\leftarrow$ crearIt(*Hippies(e.HipYEst)) \hfill \textbf{//O(1)}
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo un iterador}
 
 \caption{hippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$posEstundianteYHippie(\In{n}{nombre},\In{e}{estr}) $\rightarrow$ p: pos}
 
 \Begin{
   
   res $\leftarrow$ posEstundianteHippie(n,e.HipYEst) \hfill \textbf{//O(posEstundianteYHippie)}
   \ret{res}
 }
 \KwData{$O(Longitud del nombre)$}
 \KwComm{Devuelvo una poss}
 
 \caption{posEstundianteYHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$posAgente(\In{a}{agente},\In{e}{estr}) $\rightarrow$ p: pos}
 
 \Begin{
   
   res $\leftarrow$ posAgente(a,e.Agentes) \hfill \textbf{//O(posEstundianteYHippie)}
   \ret{res}
 }
 \KwData{$O(Longitud del nombre)$}
 \KwComm{Devuelvo una poss de un agente}
 
 \caption{posAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$cantSanciones(\In{a}{agente},\In{e}{estr}) $\rightarrow$ k: nat}
 
 \Begin{
   
   res $\leftarrow$ sancionesAgentes(a,e.Agentes) \hfill \textbf{//O(sancoiensAgentes)}
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Cantidad de sanciones de un agente}
 
 \caption{posEstundianteYHippie}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$masVigilante(\In{e}{estr}) $\rightarrow$ a: agente}
 
 \Begin{
   
   res $\leftarrow$ masVigilante(e.Agentes) \hfill \textbf{//O(1)}
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devulvo a un agente donde agenete es un placa, del mas viegilante}
 
 \caption{masVigilante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$conMismasSancioens(\In{a}{agente},\In{e}{estr}) $\rightarrow$ cA: conj(agente)}
 
 \Begin{
   
   res $\leftarrow$ conMismasSanciones(a,e.Agentes) \hfill \textbf{//O(1)}\\
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devulvo a un conj(agente) donde agenete es un placa, del mas viegilante}
 
 \caption{conMismasSanciones}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip%%%%%FIJARSE QUE MIERDA DEVUELVE SI ES UNA REFERENCIA O QUE
 
\begin{algorithm}[H]
 \text{$i$conKsanciones(\In{k}{nat},\In{e}{estr}) $\rightarrow$ cA: conj(agente)}
 
 \Begin{
   
   res $\leftarrow$ conKSanciones(k,e.Agentes) \hfill \textbf{//O(conKSanciones)}\\
   \ret{res}
 }
 \KwData{$O(Cantidad de agentes)$ la primera vez que se llama y $O(Log cantidad de agentes)$ las siguientes veces que se llama mientras no se produzcan sanciones)}
 \KwComm{Devulvo a un conj(agente) donde agenete es un placa, y el conj son todos los agentes con k sanciones}
 
 \caption{conkSanciones}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip%%%%%FIJARSE QUE MIERDA DEVUELVE SI ES UNA REFERENCIA O QUE
 
\begin{algorithm}[H]
 \text{$i$cantHippiesAtrapados(\In{a}{agente},\In{e}{estr}) $\rightarrow$ n: nat}
 
 \Begin{
   
   res $\leftarrow$ cantHippiesAtrapados(a,e.Agentes) \hfill \textbf{//O(1)}\\
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo la cantidad de hippies atrapados por un agente en particular}
 
 \caption{cantHippiesAtrapados}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$cantHippies(\In{e}{estr}) $\rightarrow$ n: nat}
 
 \Begin{
   
   res $\leftarrow$ cardinal(*Hippies(e.HipYEst)) \hfill \textbf{//O(1)}\\
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo la cantidad de hippies}
 
 \caption{cantHippies}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$cantEstudiantes(\In{e}{estr}) $\rightarrow$ n: nat}
 
 \Begin{
   
   res $\leftarrow$ cardinal(*Estudiantes(e.HipYEst)) \hfill \textbf{//O(1)}\\
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{Devuelvo la cantidad de estudiantes}
 
 \caption{cantEstudiantes}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
%%%%%%%%%%%%%%%%%%%%%%%
%% AUXILIAEREEEEEEES %%
%%%%%%%%%%%%%%%%%%%%%%%
 
 
 
 
\begin{algorithm}[H]
 \text{$i$hippieRodeadoEst(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   cantEst $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasEstudiante))}
     {
     cantEst++ \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
   res $\leftarrow$ cantEst = cantidad(cjtoVec) \hfill \textbf{//O(cantidad)}
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{me fijo si estoy rodeado por estudiantes}
 
 \caption{hippieRodeadoEst}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
\begin{algorithm}[H]
 \text{$i$hippieCapturado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   alMenos1Ag $\leftarrow$ false \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasAgente))}
     {
     alMenos1Ag $\leftarrow$ true \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
   res $\leftarrow$ alMenos1Ag $\land$ bloqueado(p,e) \hfill \textbf{//O(bloqueado)}
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{me fijo si me pueden capturar}
 
 \caption{hippieCapturado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$estudianteHippieficado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   cantHip $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasHippie))}
     {
     cantHip++ \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
   res $\leftarrow$ cantHip $\geq$ 2 \hfill \textbf{//O(1)}\\
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{me fijo si 2 vecinos mios son hippies como para atraerme al hippismo}
 
 \caption{estudianteHippieficado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$estudianteSancionar(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   alMenos1Ag $\leftarrow$ false \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasAgente))}
     {
     alMenos1Ag $\leftarrow$ true \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
   res $\leftarrow$ alMenos1Ag $\land$ bloqueado(p,e) \hfill \textbf{//O(bloqueado)}
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{me fijo si un agente me esta bloqueando}
 
 \caption{estudianteSancionar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$bloqueado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   cosasBloqueando $\leftarrow$ 0 \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?*4)}){(ocupada?(actual(Itvec),e.posOcupadasAgente) $\lor$ ocupada?(actual(Itvec),e.posOcupadasHippie)) $\lor$ ocupada?(actual(Itvec),e.posOcupadasEstudiante)) $\lor$ ocupada?(actual(Itvec),obstaculos(e.campus)))}
     {
     cosasBloqueado++ \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
   res $\leftarrow$ cosasBloqueado $=$ cantidad(cjtoVec) \hfill \textbf{//O(cantidad)}
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{me fijo si estoy bloqueado}
 
 \caption{bloqueado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$hippificar(\In{p}{pos},\Inout{e}{estr})}
 
 \Begin{
 
   definirHippie(obener(pos,e.posOcupadasEstudiante)),pos,e.HipYEst) \hfill \textbf{//O(definirHippie)}\\
   colocar(pos,obener(pos,e.posOcupadasEstudiante)),e.posOcupadasHippie) \hfill \textbf{//O(obtener) + O(colocar)}\\
   borrar(obener(pos,e.posOcupadasEstudiante)),e.HipYEst) \hfill \textbf{//O(borrar) + O(obtener)}\\
   eliminar(pos,e.posOcupadasEstudiante) \hfill \textbf{//O(eliminar)}
 }
 \KwData{Completar}
 \KwComm{transformo un estudiante a hippie}
 
 \caption{hippificar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$sancionar(\In{p}{pos},\Inout{e}{estr})}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasAgente))}
     {
       agregarSancion(obtener(actual(Itvec),e),e.agentes) \hfill \textbf{//O(agregarSancion) + O(obtener)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
 }
 \KwData{$O(1)$}
 \KwComm{sanciono agentes}
 
 \caption{sancionar}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$transformarHip(\In{p}{pos},\Inout{e}{estr})}
 
 \Begin{
 
   definirEstudiante(obener(pos,e.posOcupadasHippie)),pos,e.HipYEst) \hfill \textbf{//O(definirEstudiante) + O(obtener)}\\
   colocar(pos,obener(pos,e.posOcupadasHippie)),e.posOcupadasEstudiante) \hfill \textbf{//O(obtener) + O(colocar)}\\
   borrar(obener(pos,e.posOcupadasHippie)),e.HipYEst) \hfill \textbf{//O(borrar) + O(obtener)}\\
   eliminar(pos,e.posOcupadasHippie) \hfill \textbf{//O(eliminar)}
 }
 \KwData{Completar}
 \KwComm{transformo un hippie a estudiante}
 
 \caption{transformarHip}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$sumarCapturas(\In{p}{pos},\Inout{e}{estr})}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(ocupada?)}){ocupada?(actual(Itvec),e.posOcupadasAgente))}
     {
       agregarCaptura(obtener(actual(Itvec),e),e.agentes) \hfill \textbf{//O(agregarCaptura) + O(obtener)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
 }
 \KwData{$O(1)$}
 \KwComm{Agrego las capturas a los agentes que participaron}
 
 \caption{sumarCapturas}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$eliminarHippie(\In{p}{pos},\Inout{e}{estr})}
 
 \Begin{
 
   sumarCapturas(p,e) \hfill \textbf{//O(sumarCapturas)}\\
   borrar(obener(pos,e.posOcupadasHippie)),e.HipYEst) \hfill \textbf{//O(borrar) + O(obtener)}\\
   eliminar(pos,e.posOcupadasHippie) \hfill \textbf{//O(eliminar)}
 }
 \KwData{Completar}
 \KwComm{Elimino un hippie y agrego las capturas a los agentes que participaron de la matanza}
 
 \caption{transformarHip}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
\begin{algorithm}[H]
 \text{$i$meVoy(\In{p}{pos},\In{d}{dir},\In{e}{estr})}
 
 \Begin{
 
   res $\leftarrow$ ((ingresoSuperior(p,e.campus) $\land$ d = Arriba) $\lor$ (ingresoInferior(p,e.campus) $\land$ d = Abajo)) \hfill \textbf{//O(ingresoSuperior)+O(ingresoInferior)}
 }
 \KwData{Completar}
 \KwComm{Me fijo si me voy del campus!}
 
 \caption{meVoy}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
\begin{algorithm}[H]
 \text{$i$estMasCercano(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
 \Begin{
 \If(\hfill \textbf{//O(1)}){cantEst(e) $!=$0}
 {
   cjtoPosEst $\leftarrow$ posOcupadas(e.posOcupadasEstudiante) \hfill \textbf{//O(posOcupadas)}
   ItposEst $\leftarrow$ crearIT(cjtoPosEst) \hfill \textbf{//O(1)}
   posMasCercana $\leftarrow$ actual(ItposEst) \hfill \textbf{//O(1)}
   siguiente(ItposEst) \hfill \textbf{//O(1)}
   \While(\hfill \textbf{//O(1)}){hayMas(ItposEst)}{
     \If(\hfill \textbf{//O(1)}){ distancia(p,posMasCercana) $\geq$ distancia(p,actual(ItposEst))}
       {
         posMasCercana $\leftarrow$ actual(ItposEst) \hfill \textbf{//O(1)} \\
       }
       siguiente(ItposEst) \hfill \textbf{//O(1)} \\
   }
 
   res $\leftarrow$ posMasCercana \hfill \textbf{//O(1)}\\
 }
 {
   res $\leftarrow$ actual(crearIT(ingresoMasCercano(e.campus)) \hfill \textbf{//O(1)}
 }
 
 }
 \KwData{$O(cantidad de estudiantes)$ + constantes}
 \KwComm{Me devuelvo la poss mas cercana entre los estudiantes si no hay devuelvo un ingreso total la funcion de mover lo va a filtrar}
 
 \caption{estMasCercano}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$hipMasCercano(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
 \Begin{
 \eIf(\hfill \textbf{//O(1)}){cantHip(e) $!=$0}
   {
     cjtoPosHip $\leftarrow$ posOcupadas(e.posOcupadasHippie) \hfill \textbf{//O(posOcupadas)}
     ItposHip $\leftarrow$ crearIT(cjtoPosHip) \hfill \textbf{//O(1)}
     posMasCercana $\leftarrow$ actual(Itpoship) \hfill \textbf{//O(1)}
     siguiente(ItposHip) \hfill \textbf{//O(1)}
     \While(\hfill \textbf{//O(1)}){hayMas(ItposHip)}{
       \If(\hfill \textbf{//O(1)}){ distancia(p,posMasCercana) $\geq$ distancia(p,actual(ItposHip))}
         {
           posMasCercana $\leftarrow$ actual(Itpoship) \hfill \textbf{//O(1)} \\
         }
         siguiente(ItposHip) \hfill \textbf{//O(1)} \\
     }
 
     res $\leftarrow$ posMasCercana \hfill \textbf{//O(1)}\\
     }
   {
 
    res $\leftarrow$ actual(crearIT(ingresoMasCercano(e.campus)) \hfill \textbf{//O(1)}
   
   }
 }
 \KwData{$O(cantidad de estudiantes)$ + constantes}
 \KwComm{Me devuelvo la poss mas cercana entre los hippies}
 
 \caption{hipMasCercano}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$muevoEstudiante(\In{n}{nombre},\In{p}{pos},\In{d}{dir},\Inout{e}{estr})}
 
 \Begin{
 
  posVieja $\leftarrow$ pos \hfill \textbf{//O(1)}
  posNueva $\leftarrow$ proxPosicion(d,posVieja) \hfill \textbf{//O(1)}
  definirEstudiante(n,posNueva,e.HipYEst) \hfill \textbf{//O(definirEstudiante)}
  colocar(posNueval,n,e.posOcupadasEstudiante) \hfill \textbf{//O(colocar)}
  eliminar(posViejar,e.posOcupadasEstudiante) \hfill \textbf{//O(eliminar)}
 
 }
 \KwData{O(longitud del nombre) + constantes}
 \KwComm{Me muevo a la pos que me da la direccion}
 
 \caption{muevoEstudiante}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
 
 
 
\begin{algorithm}[H]
 \text{$i$muevoHippie(\In{p}{pos},\In{pD}{pos},\Inout{e}{estr})}
 
 \Begin{
 
  nombrehip $\leftarrow$ obtener(p,e.posOcupadasHippie) \hfill \textbf{//O(obtener)}
   \If(\hfill \textbf{//O()}){cantEst(e) $!=$ 0}
   {
     
     \eIf(\hfill \textbf{//O()}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e)) }
     {
       definirHippie(nombreHip,damePoslibre(p,e),e.HipYEst) \hfill \textbf{//O(definirHippie)}\\
       colocar(damePoslibre(p,e),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(colocar)}\\
       eliminar(damePoslibre(p,e),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(eliminar)}\\
     }
     {
       
       definirHippie(nombreHip,proxPosicion(p,dameDireccion(p,posD),e.HipYEst) \hfill \textbf{//O(definirHippie)}\\
       colocar(proxPosicion(p,dameDireccion(p,posD),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(colocar)}\\
       eliminar(proxPosicion(p,dameDireccion(p,posD),nombreHip,e.posOcupadasHippie) \hfill \textbf{//O(eliminar)}\\
     }
 
   }
 
 }
 \KwData{$O(1)$}
 \KwComm{comentario}
 
 \caption{moverHip}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$muevoAgente(\In{p}{pos},\In{pD}{pos},\Inout{e}{estr})}
 
 \Begin{
 
  nombreAg $\leftarrow$ obtener(p,e.posOcupadasAg) \hfill \textbf{//O(obtener)}
   \eIf(\hfill \textbf{//O()}){cantHip(e) $!=$ 0}
   {
     
     \eIf(\hfill \textbf{//O()}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e)) }
     {
       cambiarPosicion(nombreAg,damePoslibre(p,e),e.agentes) \hfill \textbf{//O(cambiarPosicion)}\\
       colocar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(colocar)}\\
       eliminar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(eliminar)}\\
     }
     {
       
       cambiarPosicion(nombreAg,proxPosicion(p,dameDireccion(p,posD),e.agentes) \hfill \textbf{//O(cambiarPosicion)}\\
       colocar(proxPosicion(p,dameDireccion(p,posD),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(colocar)}\\
       eliminar(proxPosicion(p,dameDireccion(p,posD),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(eliminar)}\\
     }
 
   }
   {
     posIngreso $\leftarrow$ actual(crearIT(ingresosMasCercanos(e.campus))) \hfill \textbf{//O(1)}\\
     \eIf(\hfill \textbf{//O(1)}){EstaOcupado(proxPosicion(p,dameDireccion(p,posD),e))}
     {
       cambiarPosicion(nombreAg,damePoslibre(p,e),e.agentes) \hfill \textbf{//O(cambiarPosicion)}\\
       colocar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(colocar)}\\
       eliminar(damePoslibre(p,e),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(eliminar)}\\
 
     }
     {
       cambiarPosicion(nombreAg,proxPosicion(p,dameDireccion(p,posIngreso),e.agentes) \hfill \textbf{//O(cambiarPosicion)}\\
       colocar(proxPosicion(p,dameDireccion(p,posIngreso),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(colocar)}\\
       eliminar(proxPosicion(p,dameDireccion(p,posIngreso),nombreAg,e.posOcupadasAgente) \hfill \textbf{//O(eliminar)}\\
 
     }
 
   }  
 }
 \KwData{Completaaaaaaar}
 \KwComm{muevo un agente al hippie mas cercano si esta bloqueada la poss me muevo a una cualquier si no me muevo a la correcta, si no hay hippies me muevo al ingreso mas cercano\\ con la misma metodologia que al moverme a un hippie }
 
 \caption{moverAgente}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$estaOcupado(\In{p}{pos},\In{e}{estr}) $\rightarrow$ b: bool}
 
 \Begin{
   
     res $\leftarrow$ (ocupada?(pos,e.posOcupadasAgente) $\lor$ ocupada?(pos,e.posOcupadasHippie)) $\lor$ ocupada?(pos,e.posOcupadasEstudiante)) $\lor$ ocupada?(pos,obstaculos(e.campus)))
     \hfill \textbf{//O(4*(ocupada?)}
   \ret{res}
 }
 \KwData{$O(ocupada?)$}
 \KwComm{me fijo si existe alguien en esa poss}
 
 \caption{estaOcupado}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
\begin{algorithm}[H]
 \text{$i$damePosLibre(\In{p}{pos},\In{e}{estr}) $\rightarrow$ res: pos}
 
 \Begin{
   cjtoVec $\leftarrow$ vecinos(p,e.campus) \hfill \textbf{//O(1)}\\
   Itvec $\leftarrow$ crearIT(cjtoVec) \hfill \textbf{//O(1)}\\
   \While(\hfill \textbf{//O(1)}){hayMas(Itvec)}
   {
     \If(\hfill \textbf{//O(estaOcupado)}){estaOcupado(actual(Itvec),e))}
     {
     res $\leftarrow$ actual(Itvec) \hfill \textbf{//O(1)}
     }
     siguiente(Itvec) \hfill \textbf{//O(1)}
   }
 
   \ret{res}
 }
 \KwData{$O(1)$}
 \KwComm{devuelvo Una poss libre de mis vecinos}
 
 \caption{damePosLibre}
\end{algorithm}
\rule{17.5cm}{0.4pt}
\bigskip
 
 
 
\end{Algoritmos}
 
\end{document}